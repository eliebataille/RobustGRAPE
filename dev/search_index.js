var documenterSearchIndex = {"docs":
[{"location":"api/unitary/#Unitary-Calculations","page":"Unitary Calculations","title":"Unitary Calculations","text":"","category":"section"},{"location":"api/unitary/#Unitary-Evolution-and-Derivatives","page":"Unitary Calculations","title":"Unitary Evolution and Derivatives","text":"","category":"section"},{"location":"api/unitary/#RobustGRAPE.calculate_unitary_and_derivatives","page":"Unitary Calculations","title":"RobustGRAPE.calculate_unitary_and_derivatives","text":"calculate_unitary_and_derivatives(problem::UnitaryRobustGRAPEProblem, x::Vector{<:Real})\n\nCalculate the unitary evolution operator and its derivatives with respect to control parameters and error sources.\n\nArguments\n\nproblem::UnitaryRobustGRAPEProblem: The robust GRAPE problem definition\nx::Vector{<:Real}: The optimization vector containing control parameters and additional parameters\n\nReturns\n\nA tuple with:\n\nU: Final unitary evolution\nU_dx: Derivatives with respect to control parameters\nU_dx_add: Derivatives with respect to additional parameters\nU_derr: Derivatives with respect to error sources\nU_derr_dx: Mixed derivatives (error and control parameters)\nU_derr_dx_add: Mixed derivatives (error and additional parameters)\n\n\n\n\n\n","category":"function"},{"location":"api/unitary/#RobustGRAPE.calculate_interaction_error_operators","page":"Unitary Calculations","title":"RobustGRAPE.calculate_interaction_error_operators","text":"calculate_interaction_error_operators(problem::UnitaryRobustGRAPEProblem, x::Vector{<:Real})\n\nCalculate the interaction picture representation of error operators at each time step.\n\nThis function transforms error operators from the Schrödinger picture to the interaction picture, which is essential for analyzing how errors affect the quantum dynamics throughout the evolution. The interaction picture provides a way to separate the influence of the control Hamiltonian from the error terms.\n\nParameters\n\nproblem::UnitaryRobustGRAPEProblem: The robust GRAPE problem definition\nx::Vector{<:Real}: The optimization vector containing control parameters and additional parameters\n\nReturns\n\nA tensor of dimensions (ndim, ndim, ntimes, nerr) containing the interaction picture representation of each error operator at each time step.\n\nNotes\n\nThe interaction picture transformation uses the cumulative evolution operator\nError operators are scaled by the small parameter ϵ used for numerical differentiation\nThe returned tensor has dimensions permuted for convenient access to time-dependent error operators\n\n\n\n\n\n","category":"function"},{"location":"api/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"api/types/#Core-Types","page":"Types","title":"Core Types","text":"","category":"section"},{"location":"api/types/#RobustGRAPE.ErrorSource","page":"Types","title":"RobustGRAPE.ErrorSource","text":"ErrorSource\n\nRepresents a source of error in the Hamiltonian.\n\nFields\n\nHerror::Function: A function that returns the error Hamiltonian. Signature: Herror(time::Real, x::Vector{<:Real}, x_add::Vector{<:Real}, err::Real). xhas for size the number of main parameters,x_add` has for size the number of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#RobustGRAPE.UnitaryRobustGRAPEProblem","page":"Types","title":"RobustGRAPE.UnitaryRobustGRAPEProblem","text":"UnitaryRobustGRAPEProblem\n\nRepresents a robust GRAPE unitary calculation problem.\n\nFields\n\nt0::Real: Total evolution time\nntimes::Int: Number of time steps\nndim::Int: Dimension of the Hilbert space\nH0::Function: Main Hamiltonian function. Signature: H0(time::Real, x::Vector{<:Real}, xadd::Vector{<:Real}). x has for size the number of main parameters, xadd has for size the number of additional parameters.\nnb_additional_param::Int: Number of additional parameters\nerror_sources::Vector{ErrorSource}: List of error sources\nϵ::Real = 1e-8: Small parameter for first-order finite difference\nϵ2::Real = 1e-4: Small parameter for second-order finite difference\n\n\n\n\n\n","category":"type"},{"location":"api/types/#RobustGRAPE.FidelityRobustGRAPEProblem","page":"Types","title":"RobustGRAPE.FidelityRobustGRAPEProblem","text":"FidelityRobustGRAPEProblem\n\nRepresents a robust GRAPE fidelity calculation problem.\n\nFields\n\nunitary_problem::UnitaryRobustGRAPEProblem: The underlying optimization problem\nprojector::Matrix{<:Real}: Projector for subspace fidelity\ntarget_unitary::Function: Function that returns the target unitary. Signature: target_unitary(x_add::Vector{<:Real}) where x_add has size the number of additional parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/types/#RobustGRAPE.FidelityRobustGRAPEParameters","page":"Types","title":"RobustGRAPE.FidelityRobustGRAPEParameters","text":"FidelityRobustGRAPEParameters\n\nConfiguration parameters for parameterized quantum gate optimization according to the GRAPE algorithm with optional robustness.\n\nFields\n\nx_initial::Vector{<:Real}: Initial control pulse amplitudes and additional parameters\nregularization_functions::Vector{Function}: Vector of functions to regularize the control pulses. The vector has size the number of main parameters. Each function has signature (x::Vector{<:Real}) -> (r1::Real,j1::Vector{<:Real},r2::Real,j2::Vector{<:Real}) where r1 and r2 are the first and second-order costs, and j1 and j2 are the gradients of these costs w.r.t. the control parameters. x, j1 and j2 have size ntimes.\nregularization_coeff1::Vector{<:Real}: First-order regularization coefficients; has size the number of main parameters.\nregularization_coeff2::Vector{<:Real}: Second-order regularization coefficients; has size the number of main parameters.\nerror_source_coeff::Vector{<:Real}: Coefficients for each error source. Has size the number of error sources.\ntime_limit::Real: Maximum time for optimization in seconds (NaN means no limit)\niterations::Int: Maximum number of optimization iterations\nsolver_algorithm::Optim.FirstOrderOptimizer: Optimization algorithm (e.g., LBFGS(), GradientDescent())\nadditional_parameters::Dict{Symbol,Any}: Additional parameters to pass to Optim.optimize\n\n\n\n\n\n","category":"type"},{"location":"api/fidelity/#Fidelity-Calculations","page":"Fidelity Calculations","title":"Fidelity Calculations","text":"","category":"section"},{"location":"api/fidelity/#Fidelity-Functions","page":"Fidelity Calculations","title":"Fidelity Functions","text":"","category":"section"},{"location":"api/fidelity/#RobustGRAPE.calculate_fidelity_and_derivatives","page":"Fidelity Calculations","title":"RobustGRAPE.calculate_fidelity_and_derivatives","text":"calculate_fidelity_and_derivatives(fidelity_problem::FidelityRobustGRAPEProblem, x::Vector{<:Real})\n\nCalculate the fidelity between the evolved unitary and target unitary, along with its derivatives.\n\nArguments\n\nfidelity_problem::FidelityRobustGRAPEProblem: The fidelity problem definition\nx::Vector{<:Real}: The optimization vector containing control parameters and additional parameters\n\nReturns\n\nA tuple with:\n\nF: The fidelity value\nF_dx_tot: Combined derivatives with respect to all control parameters (both main and additional)\nF_d2err: Second derivatives with respect to error sources\nF_d2err_dx_tot: Combined mixed derivatives for error and all control parameters\n\n\n\n\n\n","category":"function"},{"location":"api/fidelity/#RobustGRAPE.optimize_fidelity_and_error_sources","page":"Fidelity Calculations","title":"RobustGRAPE.optimize_fidelity_and_error_sources","text":"optimize_fidelity_and_error_sources(fidelity_problem::FidelityRobustGRAPEProblem, fidelity_parameters::FidelityRobustGRAPEParameters)\n\nOptimizes quantum control pulses while considering robustness against error sources.\n\nThis is a high-level wrapper around Optim.optimize that:\n\nCombines fidelity optimization with error robustness\nApplies regularization to the control pulses\nHandles caching to avoid redundant calculations\n\nParameters\n\nfidelity_problem::FidelityRobustGRAPEProblem: Problem definition including the Hamiltonian, target unitary, and error sources\nfidelity_parameters::FidelityRobustGRAPEParameters: Optimization parameters including initial values, regularization, and solver configuration\n\nReturns\n\nAn Optim.OptimizationResults object containing the optimization status, parameters, and diagnostics\n\nExample\n\n# Create a problem definition\nproblem = FidelityRobustGRAPEProblem(...)\n\n# Create optimization parameters\nparams = FidelityRobustGRAPEParameters(\n    x_initial = initial_x,\n    regularization_functions = [regularization_cost_phase],\n    regularization_coeff1 = [1e-6],\n    regularization_coeff2 = [1e-6],\n    error_source_coeff = [1e-3],\n    iterations = 1000,\n    solver_algorithm = LBFGS()\n)\n\n# Run the optimization\nresult = optimize_fidelity_and_error_sources(problem, params)\n\n# Get optimized parameters\noptimal_params = Optim.minimizer(result)\n\n\n\n\n\n","category":"function"},{"location":"api/fidelity/#Error-Analysis","page":"Fidelity Calculations","title":"Error Analysis","text":"","category":"section"},{"location":"api/fidelity/#RobustGRAPE.calculate_fidelity_response","page":"Fidelity Calculations","title":"RobustGRAPE.calculate_fidelity_response","text":"calculate_fidelity_response(fidelity_problem::FidelityRobustGRAPEProblem, x::Vector{<:Real}, normalized_frequencies::Vector{<:Real})\n\nCalculate the frequency-domain fidelity response function for error sources at specified frequencies.\n\nThe fidelity response function characterizes how sensitive the quantum gate is to noise at different  frequencies. This is crucial for understanding robustness against various noise spectra and can guide the design of control pulses that are specifically robust against the dominant noise frequencies in a particular experimental setup.\n\nParameters\n\nfidelity_problem::FidelityRobustGRAPEProblem: The fidelity problem definition\nx::Vector{<:Real}: The control parameters vector\nnormalized_frequencies::Vector{<:Real}: Normalized frequencies at which to evaluate the response function\n\nReturns\n\nA matrix of dimensions (nfreq, nerr) containing the fidelity response function values for each error  source at each frequency, where nfreq is the number of frequencies and nerr is the number of error sources.\n\nNotes\n\nFrequencies are normalized by Ω (the characteristic frequency of the system)\nThe response function is related to the error sensitivity: at zero frequency, the response function value is proportional to the static error sensitivity\nHigher values indicate greater sensitivity to noise at that frequency\n\n\n\n\n\n","category":"function"},{"location":"api/fidelity/#RobustGRAPE.calculate_fidelity_response_fft","page":"Fidelity Calculations","title":"RobustGRAPE.calculate_fidelity_response_fft","text":"calculate_fidelity_response_fft(fidelity_problem::FidelityRobustGRAPEProblem, x::Vector{<:Real}; oversampling::Int = 1)\n\nCalculate the frequency-domain fidelity response function using Fast Fourier Transform (FFT).\n\nThis function efficiently computes the frequency-domain fidelity response function for all error sources using FFT algorithms, which is computationally more efficient than direct calculation at specific frequencies. The implementation adds zero-padding to achieve frequency oversampling if requested.\n\nParameters\n\nfidelity_problem::FidelityRobustGRAPEProblem: The fidelity problem definition\nx::Vector{<:Real}: The control parameters vector\noversampling::Int = 1: Oversampling factor to increase the resolution of the frequency response\n\nReturns\n\nA tuple containing:\nresponse_fct_ω: Matrix of dimensions (ntimes*oversampling, nerr) containing the fidelity  response function values for each frequency and error source\nnorm_frequencies: Vector of normalized frequencies corresponding to the response function values\n\nNotes\n\nFrequencies are normalized by the quantum system's characteristic energy scale\nThe oversampling parameter allows for higher frequency resolution by zero-padding in the time domain\n\n\n\n\n\n","category":"function"},{"location":"api/fidelity/#RobustGRAPE.calculate_expectation_values","page":"Fidelity Calculations","title":"RobustGRAPE.calculate_expectation_values","text":"calculate_expectation_values(fidelity_problem::FidelityRobustGRAPEProblem, x::Vector{<:Real})\n\nCalculate the time-dependent expectation values of error generators during the quantum evolution.\n\nThis function computes how the expectation values of the error generators evolve over time under the optimized control pulse sequence. This provides insight into how errors accumulate during the quantum gate implementation and can be used to visualize the error sensitivity profile over time.\n\nParameters\n\nfidelity_problem::FidelityRobustGRAPEProblem: The fidelity problem definition\nx::Vector{<:Real}: The control parameters vector\n\nReturns\n\nA matrix of dimensions (ntimes, nerr) containing the expectation values of each error operator at each time step of the evolution.\n\nNotes\n\nThe calculation uses the cumulative sum of the interaction-picture error operators\nValues are normalized by the dimension of the projector subspace\nThe time resolution is determined by the number of time steps in the problem definition\n\n\n\n\n\n","category":"function"},{"location":"examples/#Quick-start-and-example","page":"Quick start and example","title":"Quick start and example","text":"","category":"section"},{"location":"examples/#Time-Optimal-CZ-Gate","page":"Quick start and example","title":"Time-Optimal CZ Gate","text":"","category":"section"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"This example demonstrates how to compute the time-optimal quantum CZ gate in a two-atom symmetric blockaded Rydberg system, following the work by Jandura and Pupillo.","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"This example can be found in RobustGRAPE/examples/time_optimal_cz.jl.","category":"page"},{"location":"examples/#Problem-Setup-and-Optimization","page":"Quick start and example","title":"Problem Setup and Optimization","text":"","category":"section"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"Before we define the problem computationally, a short explanation is required about the interfaces offered by the package to represent a GRAPE problem with robustness. The complete documentation can be found here.","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"We define a GRAPE problem as a Hamiltonian H0, a target unitary U0, a (pseudo)-projector on the computational subspace P, and a set of error sources (which can be empty). We leave aside errors for now and consider an ideal error-free scenario.","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"H0 and U0 may depend on control parameters, which are separated in a set of main parameters and a set of additional parameters. Main parameters may only affect H0 at a given time, while additional parameters can affect H0 at any time, as well as U0. For instance, for the Rydberg system we're considering in this example, the phase phi(t) is a main parameter, while theta, the single-qubit phase in the target unitary, is an additional parameter.","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"We represent all the parameters in a single vector in the following way:","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"x = (x_1 (t_1) x_2 (t_1) dots x_k (t_1) x_1 (t_2) dots x_k (t_n) x^(a)_1 dots x^(a)_l)","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"where t_i = t_mathrmtot times (in), k is the number of main parameters, and l is the number of additional parameters.","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"Therefore, our problem interface includes a Hamiltonian function that has for signature H(t::Real,x::Vector{<:Real},x_add::Vector{<:Real}) = some matrix, where t is the time, x is the vector of main parameters at time t, and x_add is the vector of any additional parameters. We also need to define a target unitary function target_unitary(x_add) = some matrix.","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"In this example, we work with the two-atom symmetric blockaded Rydberg Hamiltonian, expressed in the 00rangle 01rangle 11rangle 0rrangle Wrangle symmetric blockaded basis where Wrangle = (1rrangle + r1rangle)sqrt2.","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"H = \nbeginpmatrix\n0  0  0  0  0 \n0  0  0  frac(1+epsilon)e^-iphi2  0 \n0  0  0  0  frac(1+epsilon)e^-iphisqrt2 \n0  frac(1+epsilon)e^iphi2  0  delta  0 \n0  0  frac(1+epsilon)e^iphisqrt2  0  delta\nendpmatrix","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"In the Rydberg basis, our target unitary is a parametrized CZ gate, defined as a CZ gate composed with a single-qubit theta-phase gate on each qubit:","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"U = \nbeginpmatrix\n1  0  0  0  0 \n0  e^itheta  0  0  0 \n0  0  e^i(2theta+pi)  0  0 \n0  0  0  0  0 \n0  0  0  0  0\nendpmatrix","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"We define these quantities computationally using the pre-defined functions in Rydberg Tools.","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"using RobustGRAPE\nusing RobustGRAPE.RydbergTools\nusing LinearAlgebra\nusing Optim\nusing Random\nusing Setfield\n\n# Set random seed for reproducibility\nRandom.seed!(43)\n\n# Define optimization parameters\nntimes = 500  # Number of time steps\nt0 = 7.613    # Total evolution time (in units of 1/Ω)\n\n# Define Hamiltonian and target operation\n# Hamiltonian function takes time t, control parameter ϕ and additional parameters\nH0(t, ϕ, x_add) = rydberg_hamiltonian_symmetric_blockaded(ϕ[1], 0, 0)\n\n# Target operation (CZ gate) with an additional phase parameter\ncz(x_add) = cz_with_1q_phase_symmetric(x_add[1])","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"Here, rydberg_hamiltonian_symmetric_blockaded represents the above Hamiltonian. We set the intensity and detuning errors (respectively, epsilon and delta) to zero.","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"To define our robust GRAPE problem, we also need to set a (pseudo)-projector, which is used to define the computational subspace on which the average fidelity is averaged. It needs to be a diagonal matrix. The algorithm will decompose this projector into P = P_0 times W where P_0 is the projector with only ones and zeros on the diagonal, and W is a diagonal matrix that will be used to weight the trace: A mapsto tr(W A). This is relevant for systems with symmetries such that the fidelity has to be averaged with weighting specific states to account for the symmetry. For instance, in the Rydberg example we're considering, we consider a simplified Hilbert space 00rangle 01rangle 11rangle 0rrangle Wrangle. Therefore the effective trace needs to account twice for the 01rangle state. Hence we define the pseudo-projector:","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"P = mathrmdiag(12100)","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"With this in mind, we can define our problem:","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"# Create the optimization problem\nrydberg_problem = FidelityRobustGRAPEProblem(\n    UnitaryRobustGRAPEProblem(\n        t0=t0,             # Total evolution time\n        ntimes=ntimes,     # Number of time steps\n        ndim=5,            # Dimension of the Hilbert space (5 for the Rydberg system)\n        H0=H0,             # Hamiltonian function\n        nb_additional_param=1,  # One additional parameter (phase)\n        error_sources=[]   # No error sources for basic optimization\n    ),\n    collect(Diagonal([1, 2, 1, 0, 0])),  # Target state projection (computational subspace)\n    cz                          # Target operation\n)","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"Then we can define our optimization problem. Note that it would be relatively straightforward to directly use the interface we just created with the calculate_fidelity_and_derivatives to find the time-optimal gate. Nevertheless, the package offers a higher-level interface to perform this optimization more conveniently.","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"This interface minimizes a cost function:","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"C = 1-F + c_1 left( fracpartial^2 Fpartial epsilon_1^2 right)^2 + cdots + c_n_e left( fracpartial^2 Fpartial epsilon_n_e^2 right)^2 + r^(1)_1 R^(1)_1 + cdots r^(1)_k R^(1)_k + r^(2)_1 R^(2)_1 + cdots r^(2)_k R^(2)_k","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"where F is the average gate fidelity, fracpartial^2 Fpartial epsilon_i^2 is the sensitivity to an error epsilon_i, R^(1)_j and R^(2)_j are first- and second-order regularization functions that can be defined by the user for each set of main control parameters. This helps achieve a smoother pulse and can promote better convergence.","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"In this example, we don't consider any type of error, and we have a single main parameter phi(t).","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"For convenience, simple regularization functions are defined in Regularization. Here we use the regularization_cost_phase which is adapted for a phase parameter.","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"Additional parameters can be passed to the Optim.optim solver through the additional_parameters field. The list of configurable opttions for the solver can be found here.","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"# Configure optimization parameters\nrydberg_cz_parameters = FidelityRobustGRAPEParameters(\n    # Initial control pulse: small random values for the time steps + random phase\n    x_initial = [2*π*0.001*rand(ntimes); 2*π*rand()],\n    \n    # Use phase regularization to ensure smooth pulses\n    regularization_functions = [regularization_cost_phase],\n    regularization_coeff1=[1e-7],  # First derivative regularization weight\n    regularization_coeff2=[1e-7],  # Second derivative regularization weight\n    \n    error_source_coeff=Vector{Real}(),  # No error sources yet\n    time_limit=40,  # Maximum optimization time in seconds\n    \n    # Additional parameters for the optimizer\n    additional_parameters = Dict(\n        :show_trace => true,    # Show optimization progress\n        :show_every => 10,      # Display every 10 iterations\n        :g_tol => 1e-9          # Gradient tolerance for convergence\n    )\n)","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"Finally, we run the optimization:","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"# Run optimization\nres_optim_cz = optimize_fidelity_and_error_sources(rydberg_problem, rydberg_cz_parameters)\n\n# Extract optimized pulse\noptim_pulse = Optim.minimizer(res_optim_cz)\n\n# Evaluate the final fidelity\nfinal_fidelity, _, _, _ = calculate_fidelity_and_derivatives(rydberg_problem, optim_pulse)\nprintln(\"Final fidelity: $(final_fidelity)\")","category":"page"},{"location":"examples/#Visualizing-the-Optimized-Pulse","page":"Quick start and example","title":"Visualizing the Optimized Pulse","text":"","category":"section"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"We can visualize the optimized pulse using PyPlot:","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"using PyPlot\n\n# Plot the phase profile\nfig, ax = subplots()\n# Use unwrap_phase to ensure smooth phase representation\nax.plot((1:ntimes) / ntimes * t0, unwrap_phase(optim_pulse[1:ntimes]))\nax.set_title(\"Time-optimal Rydberg pulse\")\nax.set_xlabel(\"Time (1/Ω)\")\nax.set_ylabel(\"Laser phase (rad)\")","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"(Image: Time-optimal CZ gate control phase)","category":"page"},{"location":"examples/#Analyzing-the-time-optimal-gate's-error-sensitivity","page":"Quick start and example","title":"Analyzing the time-optimal gate's error sensitivity","text":"","category":"section"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"A key feature of RobustGRAPE is the ability to analyze and optimize control pulses for robustness against various sources of noise and experimental imperfections. This example demonstrates how to evaluate the sensitivity of an optimized quantum gate to common error sources.","category":"page"},{"location":"examples/#Defining-Error-Hamiltonians","page":"Quick start and example","title":"Defining Error Hamiltonians","text":"","category":"section"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"The total system Hamiltonian has to be decomposed into:","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"H(t) = H_0(t) + H_1(epsilon_1) + cdots + H_n_e(epsilon_n_e)","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"where H_i(0) = 0, and H_i(epsilon_i) represents the additional Hamiltonian due to some error epsilon_i. One may also define a noise operator O_i = fracpartial H_ipartial epsilon_i (0).","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"These Hamiltonians H_i can be used to define an error source ErrorSource(Herr) with Herr(t,x,x_add,eps) = some matrix. Here we first consider two types of error: amplitude errors on the laser drive (parametrized by \\epsilon) and angular frequency errors between the ground state manifold and the Rydberg manifold (parametrized by delta). Note that, because we consider a symmetric system, these errors apply to both atoms at the same time. Hence, the frequency errors cannot represent uncorrelated errors due to, e.g., Doppler-induced dephasing.","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"Let's define these Hamiltonians and we alter our FidelityRobustGRAPEProblem to include these error sources.","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"# Define error Hamiltonians as deviations from the ideal Hamiltonian\n\n# amplitude error: variation in the Rabi frequency (laser power)\nH_amplitude_error(t, ϕ, x_add, ϵ) = rydberg_hamiltonian_symmetric_blockaded(ϕ[1], ϵ, 0) - H0(t, ϕ, x_add)\n\n# Frequency error: variation in the laser detuning\nH_frequency_error(t, ϕ, x_add, δ) = rydberg_hamiltonian_symmetric_blockaded(ϕ[1], 0, δ) - H0(t, ϕ, x_add)\n\nrydberg_problem_with_errors = (@set rydberg_problem.unitary_problem.error_sources = [\n    ErrorSource(H_amplitude_error),\n    ErrorSource(H_frequency_error)\n])","category":"page"},{"location":"examples/#Static-error-sensitivity","page":"Quick start and example","title":"Static error sensitivity","text":"","category":"section"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"Now we can analyze how sensitive our previously optimized pulse is to a static error induced by these noise sources, by computing fracpartial^2 Fpartial epsilon_i^2. Later on, we will demonstrate how to include this sensitivity to the optimization procedure.","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"# Analyze sensitivity to errors with previously optimized pulse\nF, _, F_d2err, _ = calculate_fidelity_and_derivatives(rydberg_problem_with_errors, optim_pulse)\n\n# The F_d2err vector contains the second derivatives of fidelity with respect to error parameters\n# These values tell us how quickly the fidelity decreases with small errors\n\nprintln(\"Infidelity: $(1-F)\")\nprintln(\"Sensitivity to amplitude errors: F = 1 - $(-F_d2err[1]/2) × ϵ²\")\nprintln(\"Sensitivity to frequency errors: F = 1 - $(-F_d2err[2]/2) × δ²\")\n\n# Returns\n# Infidelity: 1.3855583347321954e-13\n# Sensitivity to amplitude errors: F = 1 - 4.211625822890814 × ϵ²\n# Sensitivity to frequency errors: F = 1 - 2.8602011006871577 × δ²","category":"page"},{"location":"examples/#Computing-the-fidelity-response-function","page":"Quick start and example","title":"Computing the fidelity response function","text":"","category":"section"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"In AMO physics, it is common to encounter systems whose noise is parametrized by a classical process described by a power spectral density. In this work, it was shown that the fidelity sensitivity to such noise processes can be efficiently described by a frequency-domain fidelity response function. This generalizes the static sensitivity generalized earlier (notably, if we note I(f) this function, then we have I(0) = -frac12 fracpartial^2 Fpartial epsilon^2).","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"Eq (8) in the reference above shows how the expected fidelity can be simply obtained from knowing the response function and the noise process (e.g. laser intensity) PSD. This package provides an efficient way to compute the response function:","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"# Calculate frequency response with oversampling for better resolution\nresponse_fct, frequencies = calculate_fidelity_response_fft(\n    rydberg_problem_with_errors, \n    optim_pulse; \n    oversampling=30  # Higher values provide smoother frequency resolution\n)\n\n# Verify that DC component matches our direct calculation\n# The DC component (zero frequency) corresponds to static parameter shifts\n@assert isapprox(-F_d2err[1], 2*response_fct[1,1], rtol=1e-3, atol=1e-3)\n@assert isapprox(-F_d2err[2], 2*response_fct[1,2], rtol=1e-3, atol=1e-3)","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"The calculate_fidelity_response_fft function computes how the gate fidelity responds to time-dependent noise at different frequencies. The returned matrices contain:","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"response_fct: A matrix of size (ntimes*oversampling,nerr)\nfrequencies: The corresponding frequency values (in units of Ω/2π) with size ntimes*oversampling.","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"Let's plot the response to intensity noise and frequency noise. Note that we apply a scaling factor to both such that we match usual conventions:","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"(12)^2 for the intensity noise because our Hamiltonian is written as a function of amplitude deviation\n(2pi)^2 for the frequency noise because our Hamiltonian is written as a function of angular frequency deviation.","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"using PyPlot\nfig, ax = subplots()\nax.plot(frequencies, 0.25 * response_fct[:,1])\nax.set_xlim(0, 3)\nax.set_ylim(0, 1.5)\nax.set_xlabel(\"2πf/Ω\")\nax.set_ylabel(\"Laser intensity noise fidelity response\")\nax.set_title(\"Time-optimal gate response to intensity noise\")","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"(Image: Time-optimal CZ gate laser intensity noise response)","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"fig, ax = subplots()\nax.plot(frequencies, (2*π)^2 * response_fct[:,2])\nax.set_xlim(0, 3)\nax.set_ylim(0, 250)\nax.set_xlabel(\"2πf/Ω\")\nax.set_ylabel(\"Laser frequency noise fidelity response\")\nax.set_title(\"Time-optimal gate response to frequency noise\")","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"(Image: Time-optimal CZ gate laser frequency noise response)","category":"page"},{"location":"examples/#Rydberg-decay-sensitivity","page":"Quick start and example","title":"Rydberg decay sensitivity","text":"","category":"section"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"To evaluate the sensitivity to the decay of the Rydberg states we can calculate the integrated Rydberg state population during gate execution:","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"# Define an operator that detects population in Rydberg states\n# The [0,0,0,1,1] pattern targets the Rydberg states in our 5-level system\ndecay_operator(t, x, x_add, ϵ) = ϵ*collect(Diagonal([0, 0, 0, 1, 1]))\n\n# Update the problem to use this detection operator\nrydberg_problem_with_decay = (@set rydberg_problem_with_decay.unitary_problem.error_sources = [\n    ErrorSource(decay_operator)\n])\n\n# Calculate expectation values throughout the gate evolution\n# The result is a matrix of values for each time step and each error source\nrydberg_pops = calculate_expectation_values(rydberg_problem_with_decay, optim_pulse)\n\n# Extract the final integrated Rydberg population (first error source, end of evolution)\nrydberg_pop = rydberg_pops[end, 1]\nprintln(\"Integrated Rydberg population: $(rydberg_pop)/Ω\")\n# Returns:\n# Integrated Rydberg population: 2.963973401634995/Ω","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"The integrated Rydberg population is a dimensionless quantity that, when multiplied by the decay rate, gives the total probability of decay during the gate operation. Lower values indicate a more resilient gate against decoherence.","category":"page"},{"location":"examples/#Amplitude-Error-Robust-CZ-Gate","page":"Quick start and example","title":"Amplitude-Error Robust CZ Gate","text":"","category":"section"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"RobustGRAPE allows us to design pulses that are resilient to specific types of errors by including the error sensitivity in the optimization cost function. Here we show how to obtain the (approximate) amplitude-error resilient pulse derived in this work for a total gate time T approx 1432Omega.","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"The full working example is available in the RobustGRAPE/examples/ar_cz.jl notebook.","category":"page"},{"location":"examples/#Setting-up-the-robust-optimization","page":"Quick start and example","title":"Setting up the robust optimization","text":"","category":"section"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"To design an amplitude-error robust gate, we include the amplitude error source in our problem definition and set a non-zero coefficient for the error sensitivity term in the cost function:","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"# Reduce the number of time steps for faster calculation\nntimes = 150\n# Define the problem with amplitude error\nrydberg_problem_ar = (@set rydberg_problem.unitary_problem.error_sources = [\n    ErrorSource(H_amplitude_error)\n])\n# Use a longer evolution time for improved robustness\nrydberg_problem_ar = (@set rydberg_problem_ar.unitary_problem.t0 = 14.32)\n\n# Configure parameters for robust optimization\nrydberg_cz_parameters_ar = (@set rydberg_cz_parameters.error_source_coeff = [1e-4])\nrydberg_cz_parameters_ar = (@set rydberg_cz_parameters_ar.time_limit = 300)\nrydberg_cz_parameters_ar = (@set rydberg_cz_parameters_ar.regularization_coeff1 = [1e-6])\nrydberg_cz_parameters_ar = (@set rydberg_cz_parameters_ar.regularization_coeff2 = [1e-6])\n\n# Run optimization\nres_optim_cz_ar = optimize_fidelity_and_error_sources(rydberg_problem_ar, rydberg_cz_parameters_ar)\noptim_pulse_ar = Optim.minimizer(res_optim_cz_ar)","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"Note that we increase the regularization coefficients as we find that it helps achieve better convergence when including error robustness in the optimization.","category":"page"},{"location":"examples/#Comparing-time-optimal-and-robust-pulses","page":"Quick start and example","title":"Comparing time-optimal and robust pulses","text":"","category":"section"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"The phase profiles of the time-optimal and amplitude-robust gates differ significantly:","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"fig, ax = subplots()\nax.plot((1:ntimes) / ntimes * t0_to, unwrap_phase(optim_pulse[1:ntimes]), label=\"Time-optimal\")\nax.plot((1:ntimes) / ntimes * t0_ar, unwrap_phase(optim_pulse_ar[1:ntimes]), label=\"Amplitude-error robust\")\nax.set_xlabel(\"Time (1/Ω)\")\nax.set_ylabel(\"Laser phase (rad)\")\nax.legend()","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"(Image: Time-optimal vs Amplitude-error robust CZ gates)","category":"page"},{"location":"examples/#Comparing-error-sensitivities-and-frequency-responses","page":"Quick start and example","title":"Comparing error sensitivities and frequency responses","text":"","category":"section"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"We can directly compare the sensitivity of both gates to various error sources:","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"# Create problem definitions with both error sources for comparison\nrydberg_problem_with_errors = (@set rydberg_problem.unitary_problem.error_sources = [\n    ErrorSource(H_amplitude_error),\n    ErrorSource(H_frequency_error)\n])\n\nrydberg_problem_with_errors_ar = (@set rydberg_problem_ar.unitary_problem.error_sources = [\n    ErrorSource(H_amplitude_error),\n    ErrorSource(H_frequency_error)\n])\n\n# Calculate frequency response for both gates\nresponse_fct, frequencies = calculate_fidelity_response_fft(rydberg_problem_with_errors,optim_pulse; oversampling=30)\nresponse_fct_ar, frequencies_ar = calculate_fidelity_response_fft(rydberg_problem_with_errors_ar,optim_pulse_ar; oversampling=30)\n\n# Compare Rydberg state population (relevant for decay)\nrydberg_pop = calculate_expectation_values(rydberg_problem_with_decay, optim_pulse)[end,1]\nrydberg_pop_ar = calculate_expectation_values(rydberg_problem_with_decay_ar, optim_pulse_ar)[end,1]\nprintln(\"Time-optimal gate\")\nprintln(\"Integrated Rydberg population: $(rydberg_pop)/Ω\")\n\nprintln(\"\\nAmplitude-error robust gate\")\nprintln(\"Integrated Rydberg population: $(rydberg_pop_ar)/Ω\")\n\n# Returns:\n# Time-optimal gate\n# Integrated Rydberg population: 2.963781384493184/Ω\n\n# Amplitude-error robust gate\n# Integrated Rydberg population: 5.198968153640445/Ω","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"The robust gate shows dramatically improved resilience against static amplitude errors compared to the time-optimal gate. This resilience comes with a steep trade-off in terms of sensitivity to dynamic intensity noise and to frequency noise, as well as increased gate duration and integrated Rydberg population:","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"(Image: Intensity noise response comparison)","category":"page"},{"location":"examples/","page":"Quick start and example","title":"Quick start and example","text":"(Image: Frequency noise response comparison)","category":"page"},{"location":"#RobustGRAPE.jl","page":"Home","title":"RobustGRAPE.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for efficient quantum optimal control with error robustness analysis and optimization.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RobustGRAPE.jl provides tools for designing high-fidelity quantum gates that are robust against noise and experimental errors. It is based on the GRadient Ascent Pulse Engineering (GRAPE) pulse algorithm: time-evolution is approximated by piecewise constant evolution operators. In addition to the bare GRAPE algorithm, this package offers tools to analyze the sensitivity of quantum gates to various errors, and can be used to design quantum gates with reduced sensitivity to certain errors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package was devised for quantum gates based on the Rydberg interaction between two atoms, but should be adaptable to many different kinds of quantum systems. It relies on analytical calculations to provide fast and accurate calculations of, e.g., the average gate fidelity and its sensitivity to error pulses, as well as the gradient of these values with respect to control parameters. On the other hand, the derivatives of each piecewise constant evolution operator are calculated using finite differences to ensure maximum adaptability to various systems. Therefore, although this package is meant to offer resonable performance, it is certainly possible to be much faster using code tailored to specific scenarios.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This paper introduces the GRAPE algorithm: N. Khaneja, T. Reiss, C. Kehlet, T. Schulte-Herbrüggen, and S. J. Glaser, Optimal control of coupled spin dynamics: Design of NMR pulse sequences by gradient ascent algorithms, J. Magn. Reson. 172, 296 (2005).","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you use the fidelity response functions in your work, please cite: Richard Bing-Shiun Tsai, Xiangkai Sun, Adam L. Shaw, Ran Finkelstein, and Manuel Endres. “Benchmarking and Fidelity Response Theory of High-Fidelity Rydberg Entangling Gates.” PRX Quantum 6, no. 1 (2025): 010331. https://doi.org/10.1103/PRXQuantum.6.010331.","category":"page"},{"location":"#Functionalities","page":"Home","title":"Functionalities","text":"","category":"section"},{"location":"#Fidelity-calculations","page":"Home","title":"Fidelity calculations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package provides a simple interface to compute:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The fidelity of a parametrized quantum gate.\nThe second-order sensitivity of the fidelity to a given noise operator.\nThe gradient of these two values w.r.t control parameters.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Based on these features, the package provides a high-level interface to minimize a global cost that includes the infidelity and the sensitivity to error sources.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Additionally, the package offers error analysis tools:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The average expectation value of a given operator (e.g., a projector onto a state that experiences some decay)\nThe fidelity response function of the fidelity to a noise described by a classical power spectral density, such as a laser noise. We invite the reader to familiarize themselves with this tool in the above reference.","category":"page"},{"location":"#Unitary-calculations","page":"Home","title":"Unitary calculations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"At a lower level, the fidelity tools rely on the ability to efficiently compute the total unitary gate, the derivative of this unitary w.r.t. control parameters, the derivative of this unitary w.r.t. error sources, and the derivative of this unitary w.r.t. error sources and control parameters. For users that wish to work with a different quantity than the fidelity, they can directly access the corresponding methods.","category":"page"},{"location":"#Regularization","page":"Home","title":"Regularization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Provides simple functionalities to regularize control parameters and their derivatives. Regularization can promote convergence to smooth high-fidelity pulses.","category":"page"},{"location":"#Rydberg-tools","page":"Home","title":"Rydberg tools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Provides pre-defined Hamiltonian and parametrized CZ gates for a two-atom Rydberg system.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is currently not available on the Julia Register, but can be installed directly by the user:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/srtweezer/RobustGRAPE\")","category":"page"},{"location":"#Quick-start-and-Documentation","page":"Home","title":"Quick start & Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Please see the online documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For quick start, please consult the Rydberg 2-atom time-optimal gate example, which showcases most features in the package.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Check out the Examples page for a working example, including notably:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Time-optimal CZ gate implementation using Rydberg atoms\nRobust pulse design against intensity and frequency errors\nFrequency domain analysis of optimized pulses","category":"page"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package's documentation and code organization was developed with the assistance of Claude, an AI assistant by Anthropic.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is licensed under the MIT License - see the LICENSE file for details.","category":"page"},{"location":"#Acknowledgments-2","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package was developed with assistance from Claude, particularly for documentation and code organization.","category":"page"},{"location":"api/rydberg/#Rydberg-Tools","page":"Rydberg Tools","title":"Rydberg Tools","text":"","category":"section"},{"location":"api/rydberg/#Rydberg-Specific-Functions","page":"Rydberg Tools","title":"Rydberg-Specific Functions","text":"","category":"section"},{"location":"api/rydberg/","page":"Rydberg Tools","title":"Rydberg Tools","text":"This page documents functions specific to Rydberg atom systems in RobustGRAPE.jl.","category":"page"},{"location":"api/rydberg/#Hamiltonian-Functions","page":"Rydberg Tools","title":"Hamiltonian Functions","text":"","category":"section"},{"location":"api/rydberg/#RobustGRAPE.RydbergTools.rydberg_hamiltonian_symmetric_blockaded","page":"Rydberg Tools","title":"RobustGRAPE.RydbergTools.rydberg_hamiltonian_symmetric_blockaded","text":"rydberg_hamiltonian_symmetric_blockaded(ϕ::Real, ϵ::Real, δ::Real)\n\nConstructs the Hamiltonian for a symmetric Rydberg-blockaded two-atom system.\n\nBasis\n\n|00⟩, |01⟩, |11⟩, |0r⟩, |W⟩ where |W⟩ = (|1r⟩ + |r1⟩)/√2\n\nParameters\n\nϕ::Real: Phase of the driving field\nϵ::Real: Relative amplitude deviation parameter\nδ::Real: Detuning of the Rydberg state\n\nMathematical form\n\nH = \nbeginpmatrix\n0  0  0  0  0 \n0  0  0  frac(1+epsilon)e^-iphi2  0 \n0  0  0  0  frac(1+epsilon)e^-iphisqrt2 \n0  frac(1+epsilon)e^iphi2  0  delta  0 \n0  0  frac(1+epsilon)e^iphisqrt2  0  delta\nendpmatrix\n\nReturns\n\nMatrix representing the Hamiltonian in the symmetric basis described above\n\n\n\n\n\n","category":"function"},{"location":"api/rydberg/#RobustGRAPE.RydbergTools.rydberg_hamiltonian_full_blockaded","page":"Rydberg Tools","title":"RobustGRAPE.RydbergTools.rydberg_hamiltonian_full_blockaded","text":"rydberg_hamiltonian_full_blockaded(ϕ::Real, ϵ::Real, δ::Real)\n\nConstructs the Hamiltonian for a fully-described Rydberg-blockaded two-atom system.\n\nBasis\n\n|00⟩, |01⟩, |10⟩, |11⟩, |0r⟩, |r0⟩, |W'⟩ where |W'⟩ = (|1r⟩ + |r1⟩)/√2\n\nParameters\n\nϕ::Real: Phase of the driving field\nϵ::Real: Relative amplitude deviation parameter\nδ::Real: Detuning of the Rydberg state\n\nMathematical form\n\nH = \nbeginpmatrix\n0  0  0  0  0  0  0 \n0  0  0  0  frac(1+epsilon)e^-iphi2  0  0 \n0  0  0  0  0  frac(1+epsilon)e^-iphi2  0 \n0  0  0  0  0  0  frac(1+epsilon)e^-iphisqrt2 \n0  frac(1+epsilon)e^iphi2  0  0  delta  0  0 \n0  0  frac(1+epsilon)e^iphi2  0  0  delta  0 \n0  0  0  frac(1+epsilon)e^iphisqrt2  0  0  delta\nendpmatrix\n\nReturns\n\nMatrix representing the Hamiltonian in the basis described above\n\n\n\n\n\n","category":"function"},{"location":"api/rydberg/#RobustGRAPE.RydbergTools.rydberg_hamiltonian_full","page":"Rydberg Tools","title":"RobustGRAPE.RydbergTools.rydberg_hamiltonian_full","text":"rydberg_hamiltonian_full(ϕ::Real, Ω1::Real, Ω2::Real, δ1::Real, δ2::Real, B::Real)\n\nConstructs the full Hamiltonian for a two-atom Rydberg system without symmetry constraints.\n\nBasis\n\n|00⟩, |01⟩, |10⟩, |11⟩, |0r⟩, |r0⟩, |1r⟩, |r1⟩, |rr⟩\n\nParameters\n\nϕ::Real: Phase of the driving field\nΩ1::Real: Rabi frequency for the first atom\nΩ2::Real: Rabi frequency for the second atom\nδ1::Real: Detuning for the first atom\nδ2::Real: Detuning for the second atom\nB::Real: Rydberg-Rydberg blockade shift\n\nMathematical form\n\nH = \nbeginpmatrix\n0  0  0  0  0  0  0  0  0 \n0  0  0  0  fracOmega_1 e^-iphi2  0  0  0  0 \n0  0  0  0  0  fracOmega_2 e^-iphi2  0  0  0 \n0  0  0  0  0  0  fracOmega_1 e^-iphi2  Omega_2 e^-iphi  0 \n0  fracOmega_1 e^iphi2  0  0  delta_1  0  0  0  0 \n0  0  fracOmega_2 e^iphi2  0  0  delta_2  0  0  0 \n0  0  0  0  fracOmega_1 e^iphi2  0  delta_1  0  fracOmega_2 e^-iphi2 \n0  0  0  0  0  fracOmega_2 e^iphi2  0  delta_2  fracOmega_1 e^-iphi2 \n0  0  0  0  0  0  fracOmega_2 e^iphi2  fracOmega_1 e^iphi2  delta_1 + delta_2 + B\nendpmatrix\n\nReturns\n\nMatrix representing the Hamiltonian in the full basis described above\n\n\n\n\n\n","category":"function"},{"location":"api/rydberg/#Gate-Functions","page":"Rydberg Tools","title":"Gate Functions","text":"","category":"section"},{"location":"api/rydberg/#RobustGRAPE.RydbergTools.cz_with_1q_phase_symmetric","page":"Rydberg Tools","title":"RobustGRAPE.RydbergTools.cz_with_1q_phase_symmetric","text":"cz_with_1q_phase_symmetric(θ::Real)\n\nConstructs the CZ gate with additional single-qubit phase in the symmetric subspace.\n\nBasis\n\n|00⟩, |01⟩, |11⟩, |0r⟩, |W⟩ (same as in rydberg_hamiltonian_symmetric_blockaded)\n\nParameters\n\nθ::Real: Single-qubit phase parameter\n\nMathematical form\n\nU = \nbeginpmatrix\n1  0  0  0  0 \n0  e^itheta  0  0  0 \n0  0  e^i(2theta+pi)  0  0 \n0  0  0  0  0 \n0  0  0  0  0\nendpmatrix\n\nThe diagonal structure encodes a CZ gate with additional single-qubit phase rotations.\n\nReturns\n\nDiagonal matrix representing the CZ gate with phase rotations\n\n\n\n\n\n","category":"function"},{"location":"api/rydberg/#RobustGRAPE.RydbergTools.cz_with_1q_phase_full","page":"Rydberg Tools","title":"RobustGRAPE.RydbergTools.cz_with_1q_phase_full","text":"cz_with_1q_phase_full(θ::Real; rydberg_dimension::Int = 5)\n\nConstructs the CZ gate with additional single-qubit phase in the full computational basis.\n\nBasis\n\n|00⟩, |01⟩, |10⟩, |11⟩, |0r⟩, |r0⟩, |1r⟩, |r1⟩, |rr⟩ (same as in rydberg_hamiltonian_full)\n\nParameters\n\nθ::Real: Single-qubit phase parameter\nrydberg_dimension::Int=5: Dimension of the Rydberg subspace (optional, default: 5)\n\nMathematical form\n\nU = \nbeginpmatrix\n1  0  0  0  0  0  0  0  0 \n0  e^itheta  0  0  0  0  0  0  0 \n0  0  e^itheta  0  0  0  0  0  0 \n0  0  0  e^i(2theta+pi)  0  0  0  0  0 \n0  0  0  0  0  0  0  0  0 \n0  0  0  0  0  0  0  0  0 \n0  0  0  0  0  0  0  0  0 \n0  0  0  0  0  0  0  0  0 \n0  0  0  0  0  0  0  0  0\nendpmatrix\n\nThe diagonal structure encodes a CZ gate with additional single-qubit phase rotations.\n\nReturns\n\nDiagonal matrix representing the CZ gate with phase rotations in the full basis\n\n\n\n\n\n","category":"function"},{"location":"api/rydberg/#Utility-Functions","page":"Rydberg Tools","title":"Utility Functions","text":"","category":"section"},{"location":"api/rydberg/#RobustGRAPE.RydbergTools.unwrap_phase","page":"Rydberg Tools","title":"RobustGRAPE.RydbergTools.unwrap_phase","text":"unwrap_phase(ϕ)\n\nUnwraps a sequence of phase values by removing jumps greater than π.\n\nAdjusts phase values to maintain continuity across the 2π boundary, eliminating artificial discontinuities in phase data while preserving the actual phase evolution. Particularly useful for plotting phase values to avoid discontinuous jumps.\n\nParameters\n\nϕ: Array of phase values to unwrap\n\nReturns\n\nAn array of unwrapped phase values with the same length as the input\n\n\n\n\n\n","category":"function"},{"location":"api/regularization/#Regularization","page":"Regularization","title":"Regularization","text":"","category":"section"},{"location":"api/regularization/#Regularization-Functions","page":"Regularization","title":"Regularization Functions","text":"","category":"section"},{"location":"api/regularization/","page":"Regularization","title":"Regularization","text":"This page documents the regularization functions available in RobustGRAPE.jl, which are used to enforce desirable properties on the optimized control pulses such as smoothness and bounded amplitudes.","category":"page"},{"location":"api/regularization/#RobustGRAPE.regularization_cost","page":"Regularization","title":"RobustGRAPE.regularization_cost","text":"regularization_cost(x::Vector{<:Real})\n\nCompute regularization costs and their gradients to promote smoothness in control pulses.\n\nThis function calculates two regularization terms:\n\nFirst-order regularization (reg1): Penalizes large changes between consecutive elements (first derivative)\nSecond-order regularization (reg2): Penalizes large changes in the rate of change (second derivative)\n\nArguments\n\nx::Vector{<:Real}: The control parameter vector to regularize\n\nReturns\n\nA tuple with four elements:\n\nreg1::Real: First-order regularization cost (sum of squared differences)\njac1::Vector{<:Real}: Gradient of the first-order regularization with respect to x\nreg2::Real: Second-order regularization cost (sum of squared second differences)\njac2::Vector{<:Real}: Gradient of the second-order regularization with respect to x\n\nExamples\n\nx = [0.0, 0.1, 0.3, 0.2, 0.1]\nreg1, jac1, reg2, jac2 = regularization_cost(x)\n\n\n\n\n\nregularization_cost(x::Vector{<:Real}, f::Function, df::Function)\n\nCompute regularization costs and their gradients for transformed control parameters.\n\nThis function applies a transformation function f to the control parameters before calculating regularization, and then applies the chain rule using df to compute the gradient with respect to the original parameters.\n\nArguments\n\nx::Vector{<:Real}: The original control parameter vector\nf::Function: Transformation function to apply to each element of x\ndf::Function: Derivative of the transformation function\n\nReturns\n\nA tuple with four elements:\n\nreg1::Real: First-order regularization cost on the transformed parameters\njac1::Vector{<:Real}: Gradient of the first-order regularization with respect to original parameters\nreg2::Real: Second-order regularization cost on the transformed parameters\njac2::Vector{<:Real}: Gradient of the second-order regularization with respect to original parameters\n\nExamples\n\nx = [0.0, 0.1, 0.3, 0.2, 0.1]\nf(x) = sin(x)\ndf(x) = cos(x)\nreg1, jac1, reg2, jac2 = regularization_cost(x, f, df)\n\n\n\n\n\n","category":"function"},{"location":"api/regularization/#RobustGRAPE.regularization_cost_phase","page":"Regularization","title":"RobustGRAPE.regularization_cost_phase","text":"regularization_cost_phase(ϕs::Vector{<:Real})\n\nCompute regularization costs and their gradients for phase-based control parameters.\n\nThis function calculates regularization terms for both sine and cosine of the phase values, which promotes smoothness in the complex phasor representation of the phase controls. This is particularly useful when optimizing phase-based control sequences where the physical meaning depends on the periodic nature of phases.\n\nArguments\n\nϕs::Vector{<:Real}: The vector of phase values (in radians) to regularize\n\nReturns\n\nA tuple with four elements:\n\nreg1::Real: First-order regularization cost (sum of cos and sin components)\njac1::Vector{<:Real}: Gradient of the first-order regularization with respect to ϕs\nreg2::Real: Second-order regularization cost (sum of cos and sin components)\njac2::Vector{<:Real}: Gradient of the second-order regularization with respect to ϕs\n\nExamples\n\nϕs = [0.0, 0.1, 0.3, 0.2, 0.1]\nreg1, jac1, reg2, jac2 = regularization_cost_phase(ϕs)\n\n\n\n\n\n","category":"function"},{"location":"api/regularization/","page":"Regularization","title":"Regularization","text":"Note: Add other regularization functions from Regularization.jl as they are implemented.","category":"page"}]
}
