var documenterSearchIndex = {"docs":
[{"location":"api/unitary/#Unitary-Calculations","page":"Unitary Calculations","title":"Unitary Calculations","text":"","category":"section"},{"location":"api/unitary/#Unitary-Evolution-and-Derivatives","page":"Unitary Calculations","title":"Unitary Evolution and Derivatives","text":"","category":"section"},{"location":"api/unitary/#RobustGRAPE.calculate_unitary_and_derivatives","page":"Unitary Calculations","title":"RobustGRAPE.calculate_unitary_and_derivatives","text":"calculate_unitary_and_derivatives(problem::UnitaryRobustGRAPEProblem, x::Vector{<:Real})\n\nCalculate the unitary evolution operator and its derivatives with respect to control parameters and error sources.\n\nArguments\n\nproblem::UnitaryRobustGRAPEProblem: The robust GRAPE problem definition\nx::Vector{<:Real}: The optimization vector containing control parameters and additional parameters\n\nReturns\n\nA tuple with:\n\nU: Final unitary evolution\nU_dx: Derivatives with respect to control parameters\nU_dx_add: Derivatives with respect to additional parameters\nU_derr: Derivatives with respect to error sources\nU_derr_dx: Mixed derivatives (error and control parameters)\nU_derr_dx_add: Mixed derivatives (error and additional parameters)\n\n\n\n\n\n","category":"function"},{"location":"api/unitary/#RobustGRAPE.calculate_interaction_error_operators","page":"Unitary Calculations","title":"RobustGRAPE.calculate_interaction_error_operators","text":"calculate_interaction_error_operators(problem::UnitaryRobustGRAPEProblem, x::Vector{<:Real})\n\nCalculate the interaction picture representation of error operators at each time step.\n\nThis function transforms error operators from the Schrödinger picture to the interaction picture, which is essential for analyzing how errors affect the quantum dynamics throughout the evolution. The interaction picture provides a way to separate the influence of the control Hamiltonian from the error terms.\n\nParameters\n\nproblem::UnitaryRobustGRAPEProblem: The robust GRAPE problem definition\nx::Vector{<:Real}: The optimization vector containing control parameters and additional parameters\n\nReturns\n\nA tensor of dimensions (ndim, ndim, ntimes, nerr) containing the interaction picture representation of each error operator at each time step.\n\nNotes\n\nThe interaction picture transformation uses the cumulative evolution operator\nError operators are scaled by the small parameter ϵ used for numerical differentiation\nThe returned tensor has dimensions permuted for convenient access to time-dependent error operators\n\n\n\n\n\n","category":"function"},{"location":"api/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"api/types/#Core-Types","page":"Types","title":"Core Types","text":"","category":"section"},{"location":"api/types/#RobustGRAPE.ErrorSource","page":"Types","title":"RobustGRAPE.ErrorSource","text":"ErrorSource\n\nRepresents a source of error in the Hamiltonian.\n\nFields\n\nHerror::Function: A function that returns the error Hamiltonian. Signature: Herror(time, x, x_add, err)\n\n\n\n\n\n","category":"type"},{"location":"api/types/#RobustGRAPE.UnitaryRobustGRAPEProblem","page":"Types","title":"RobustGRAPE.UnitaryRobustGRAPEProblem","text":"UnitaryRobustGRAPEProblem\n\nRepresents a robust GRAPE optimization problem.\n\nFields\n\nt0::Real: Total evolution time\nntimes::Int: Number of time steps\nndim::Int: Dimension of the Hilbert space\nH0::Function: Main Hamiltonian function. Signature: H0(time, x, x_add)\nnb_additional_param::Int: Number of additional parameters\nerror_sources::Vector{ErrorSource}: List of error sources\nϵ::Real: Small parameter for numerical differentiation\nϵ2::Real: Second small parameter for numerical differentiation\n\n\n\n\n\n","category":"type"},{"location":"api/types/#RobustGRAPE.FidelityRobustGRAPEProblem","page":"Types","title":"RobustGRAPE.FidelityRobustGRAPEProblem","text":"FidelityRobustGRAPEProblem\n\nRepresents a robust GRAPE problem with fidelity calculation.\n\nFields\n\nunitary_problem::UnitaryRobustGRAPEProblem: The underlying optimization problem\nprojector::Matrix{Real}: Projector for subspace fidelity\ntarget_unitary::Function: Function that returns the target unitary. Signature: targetunitary(xadd)\n\n\n\n\n\n","category":"type"},{"location":"api/types/#RobustGRAPE.FidelityRobustGRAPEParameters","page":"Types","title":"RobustGRAPE.FidelityRobustGRAPEParameters","text":"FidelityRobustGRAPEParameters\n\nConfiguration parameters for robust quantum control optimization.\n\nFields\n\nx_initial::Vector{<:Real}: Initial control pulse amplitudes and additional parameters\nregularization_functions::Vector{Function}: Functions to regularize the control pulses (one per parameter type)\nregularization_coeff1::Vector{<:Real}: First-order regularization coefficients\nregularization_coeff2::Vector{<:Real}: Second-order regularization coefficients\nerror_source_coeff::Vector{<:Real}: Coefficients for each error source (must match error_sources in the problem)\ntime_limit::Real: Maximum time for optimization in seconds (NaN means no limit)\niterations::Int: Maximum number of optimization iterations\nsolver_algorithm::Optim.FirstOrderOptimizer: Optimization algorithm (e.g., LBFGS(), GradientDescent())\nadditional_parameters::Dict{Symbol,Any}: Additional parameters to pass to Optim.optimize\n\n\n\n\n\n","category":"type"},{"location":"api/fidelity/#Fidelity-Calculations","page":"Fidelity Calculations","title":"Fidelity Calculations","text":"","category":"section"},{"location":"api/fidelity/#Fidelity-Functions","page":"Fidelity Calculations","title":"Fidelity Functions","text":"","category":"section"},{"location":"api/fidelity/#RobustGRAPE.calculate_fidelity_and_derivatives","page":"Fidelity Calculations","title":"RobustGRAPE.calculate_fidelity_and_derivatives","text":"calculate_fidelity_and_derivatives(fidelity_problem::FidelityRobustGRAPEProblem, x::Vector{<:Real})\n\nCalculate the fidelity between the evolved unitary and target unitary, along with its derivatives.\n\nArguments\n\nfidelity_problem::FidelityRobustGRAPEProblem: The fidelity problem definition\nx::Vector{<:Real}: The optimization vector containing control parameters and additional parameters\n\nReturns\n\nA tuple with:\n\nF: The fidelity value\nF_dx_tot: Combined derivatives with respect to all control parameters (both main and additional)\nF_d2err: Second derivatives with respect to error sources\nF_d2err_dx_tot: Combined mixed derivatives for error and all control parameters\n\n\n\n\n\n","category":"function"},{"location":"api/fidelity/#RobustGRAPE.optimize_fidelity_and_error_sources","page":"Fidelity Calculations","title":"RobustGRAPE.optimize_fidelity_and_error_sources","text":"optimize_fidelity_and_error_sources(fidelity_problem::FidelityRobustGRAPEProblem, fidelity_parameters::FidelityRobustGRAPEParameters)\n\nOptimizes quantum control pulses while considering robustness against error sources.\n\nThis is a high-level wrapper around Optim.optimize that:\n\nCombines fidelity optimization with error robustness\nApplies regularization to the control pulses\nHandles caching to avoid redundant calculations\n\nParameters\n\nfidelity_problem::FidelityRobustGRAPEProblem: Problem definition including the Hamiltonian, target unitary, and error sources\nfidelity_parameters::FidelityRobustGRAPEParameters: Optimization parameters including initial values, regularization, and solver configuration\n\nReturns\n\nAn Optim.OptimizationResults object containing the optimization status, parameters, and diagnostics\n\nExample\n\n# Create a problem definition\nproblem = FidelityRobustGRAPEProblem(...)\n\n# Create optimization parameters\nparams = FidelityRobustGRAPEParameters(\n    x_initial = initial_x,\n    regularization_functions = [regularization_cost_phase],\n    regularization_coeff1 = [1e-6],\n    regularization_coeff2 = [1e-6],\n    error_source_coeff = [1e-3],\n    iterations = 1000,\n    solver_algorithm = LBFGS()\n)\n\n# Run the optimization\nresult = optimize_fidelity_and_error_sources(problem, params)\n\n# Get optimized parameters\noptimal_params = Optim.minimizer(result)\n\n\n\n\n\n","category":"function"},{"location":"api/fidelity/#Error-Analysis","page":"Fidelity Calculations","title":"Error Analysis","text":"","category":"section"},{"location":"api/fidelity/#RobustGRAPE.calculate_fidelity_response","page":"Fidelity Calculations","title":"RobustGRAPE.calculate_fidelity_response","text":"calculate_fidelity_response(fidelity_problem::FidelityRobustGRAPEProblem, x::Vector{<:Real}, normalized_frequencies::Vector{<:Real})\n\nCalculate the frequency-domain fidelity response function for error sources at specified frequencies.\n\nThe fidelity response function characterizes how sensitive the quantum gate is to noise at different  frequencies. This is crucial for understanding robustness against various noise spectra and can guide the design of control pulses that are specifically robust against the dominant noise frequencies in a particular experimental setup.\n\nParameters\n\nfidelity_problem::FidelityRobustGRAPEProblem: The fidelity problem definition\nx::Vector{<:Real}: The control parameters vector\nnormalized_frequencies::Vector{<:Real}: Normalized frequencies at which to evaluate the response function\n\nReturns\n\nA matrix of dimensions (nfreq, nerr) containing the fidelity response function values for each error  source at each frequency, where nfreq is the number of frequencies and nerr is the number of error sources.\n\nNotes\n\nFrequencies are normalized by Ω (the characteristic frequency of the system)\nThe response function is related to the error sensitivity: at zero frequency, the response function value is proportional to the static error sensitivity\nHigher values indicate greater sensitivity to noise at that frequency\n\n\n\n\n\n","category":"function"},{"location":"api/fidelity/#RobustGRAPE.calculate_fidelity_response_fft","page":"Fidelity Calculations","title":"RobustGRAPE.calculate_fidelity_response_fft","text":"calculate_fidelity_response_fft(fidelity_problem::FidelityRobustGRAPEProblem, x::Vector{<:Real}; oversampling::Int = 1)\n\nCalculate the frequency-domain fidelity response function using Fast Fourier Transform (FFT).\n\nThis function efficiently computes the frequency-domain fidelity response function for all error sources using FFT algorithms, which is computationally more efficient than direct calculation at specific frequencies. The implementation adds zero-padding to achieve frequency oversampling if requested.\n\nParameters\n\nfidelity_problem::FidelityRobustGRAPEProblem: The fidelity problem definition\nx::Vector{<:Real}: The control parameters vector\noversampling::Int = 1: Oversampling factor to increase the resolution of the frequency response\n\nReturns\n\nA tuple containing:\nresponse_fct_ω: Matrix of dimensions (ntimes*oversampling, nerr) containing the fidelity  response function values for each frequency and error source\nnorm_frequencies: Vector of normalized frequencies corresponding to the response function values\n\nNotes\n\nFrequencies are normalized by the quantum system's characteristic energy scale\nThe oversampling parameter allows for higher frequency resolution by zero-padding in the time domain\n\n\n\n\n\n","category":"function"},{"location":"api/fidelity/#RobustGRAPE.calculate_expectation_values","page":"Fidelity Calculations","title":"RobustGRAPE.calculate_expectation_values","text":"calculate_expectation_values(fidelity_problem::FidelityRobustGRAPEProblem, x::Vector{<:Real})\n\nCalculate the time-dependent expectation values of error generators during the quantum evolution.\n\nThis function computes how the expectation values of the error generators evolve over time under the optimized control pulse sequence. This provides insight into how errors accumulate during the quantum gate implementation and can be used to visualize the error sensitivity profile over time.\n\nParameters\n\nfidelity_problem::FidelityRobustGRAPEProblem: The fidelity problem definition\nx::Vector{<:Real}: The control parameters vector\n\nReturns\n\nA matrix of dimensions (ntimes, nerr) containing the expectation values of each error operator at each time step of the evolution.\n\nNotes\n\nThe calculation uses the cumulative sum of the interaction-picture error operators\nValues are normalized by the dimension of the projector subspace\nThe time resolution is determined by the number of time steps in the problem definition\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Time-Optimal-CZ-Gate","page":"Examples","title":"Time-Optimal CZ Gate","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"This example demonstrates how to optimize a CZ gate in a Rydberg atom system with minimal gate time. The optimization is based on the GRAPE algorithm which divides the control pulse into discrete time steps and optimizes the control parameters at each step.","category":"page"},{"location":"examples/#Problem-Setup-and-Optimization","page":"Examples","title":"Problem Setup and Optimization","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"First, we import the necessary packages and set up the problem:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using RobustGRAPE\nusing RobustGRAPE.RydbergTools\nusing LinearAlgebra\nusing Optim\nusing Random\nusing Setfield\n\n# Set random seed for reproducibility\nRandom.seed!(43)\n\n# Define optimization parameters\nntimes = 500  # Number of time steps\nt0 = 7.613    # Total evolution time (in units of 1/Ω)\n\n# Define Hamiltonian and target operation\n# Hamiltonian function takes time t, control parameter ϕ and additional parameters\nH0(t, ϕ, x_add) = rydberg_hamiltonian_symmetric_blockaded(ϕ[1], 0, 0)\n\n# Target operation (CZ gate) with an additional phase parameter\ncz(x_add) = cz_with_1q_phase_symmetric(x_add[1])","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here, rydberg_hamiltonian_symmetric_blockaded represents the Hamiltonian of a Rydberg atom system in a blockade configuration. The function takes the laser phase ϕ[1] as its first argument, with additional parameters for intensity and detuning errors (set to 0 here).","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next, we create the optimization problem:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Create the optimization problem\nrydberg_problem = FidelityRobustGRAPEProblem(\n    UnitaryRobustGRAPEProblem(\n        t0=t0,             # Total evolution time\n        ntimes=ntimes,     # Number of time steps\n        ndim=5,            # Dimension of the Hilbert space (5 for the Rydberg system)\n        H0=H0,             # Hamiltonian function\n        nb_additional_param=1,  # One additional parameter (phase)\n        error_sources=[]   # No error sources for basic optimization\n    ),\n    Diagonal([1, 2, 1, 0, 0]),  # Target state projection (computational subspace)\n    cz                          # Target operation\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The problem setup involves:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"A UnitaryRobustGRAPEProblem that defines the physical system and dynamics\nA FidelityRobustGRAPEProblem that adds the target operation and subspace projection\nThe projection Diagonal([1, 2, 1, 0, 0]) restricts the optimization to the computational subspace","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we configure the optimization parameters:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Configure optimization parameters\nrydberg_cz_parameters = FidelityRobustGRAPEParameters(\n    # Initial control pulse: small random values for the time steps + random phase\n    x_initial = [2*π*0.001*rand(ntimes); 2*π*rand()],\n    \n    # Use phase regularization to ensure smooth pulses\n    regularization_functions = [regularization_cost_phase],\n    regularization_coeff1=[1e-7],  # First derivative regularization weight\n    regularization_coeff2=[1e-7],  # Second derivative regularization weight\n    \n    error_source_coeff=Vector{Real}(),  # No error sources yet\n    time_limit=40,  # Maximum optimization time in seconds\n    \n    # Additional parameters for the optimizer\n    additional_parameters = Dict(\n        :show_trace => true,    # Show optimization progress\n        :show_every => 10,      # Display every 10 iterations\n        :g_tol => 1e-9          # Gradient tolerance for convergence\n    )\n)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The regularization_cost_phase function is particularly important for phase-based control, as it ensures smooth transitions in the phase values, which is crucial for experimental implementation.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Finally, we run the optimization:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Run optimization\nres_optim_cz = optimize_fidelity_and_error_sources(rydberg_problem, rydberg_cz_parameters)\n\n# Extract optimized pulse\noptim_pulse = Optim.minimizer(res_optim_cz)\n\n# Evaluate the final fidelity\nfinal_fidelity, _, _, _ = calculate_fidelity_and_derivatives(rydberg_problem, optim_pulse)\nprintln(\"Final fidelity: $(final_fidelity)\")","category":"page"},{"location":"examples/#Visualizing-the-Optimized-Pulse","page":"Examples","title":"Visualizing the Optimized Pulse","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can visualize the optimized pulse using PyPlot:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using PyPlot\n\n# Plot the phase profile\nfig, ax = subplots()\n# Use unwrap_phase to ensure smooth phase representation\nax.plot((1:ntimes) / ntimes * t0, unwrap_phase(optim_pulse[1:ntimes]))\nax.set_title(\"Time-optimal Rydberg pulse\")\nax.set_xlabel(\"Time (1/Ω)\")\nax.set_ylabel(\"Laser phase (rad)\")","category":"page"},{"location":"examples/#Robust-Control-Pulse-Design","page":"Examples","title":"Robust Control Pulse Design","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A key feature of RobustGRAPE is the ability to analyze and optimize control pulses for robustness against various sources of noise and experimental imperfections. This example demonstrates how to evaluate the sensitivity of an optimized quantum gate to common error sources.","category":"page"},{"location":"examples/#Defining-Error-Hamiltonians","page":"Examples","title":"Defining Error Hamiltonians","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"First, we need to define how different error sources affect our system Hamiltonian:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Define error Hamiltonians as deviations from the ideal Hamiltonian\n\n# Intensity error: variation in the Rabi frequency (laser power)\nH_intensity_error(t, ϕ, x_add, ϵ) = rydberg_hamiltonian_symmetric_blockaded(ϕ[1], ϵ, 0) - H0(t, ϕ, x_add)\n\n# Frequency error: variation in the laser detuning\nH_frequency_error(t, ϕ, x_add, δ) = rydberg_hamiltonian_symmetric_blockaded(ϕ[1], 0, δ) - H0(t, ϕ, x_add)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Each error Hamiltonian represents how the system dynamics change when a specific parameter deviates from its nominal value:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The intensity error (ϵ) represents fluctuations in the laser power or coupling strength\nThe frequency error (δ) represents fluctuations in the laser frequency or detuning","category":"page"},{"location":"examples/#Creating-a-Problem-with-Error-Sources","page":"Examples","title":"Creating a Problem with Error Sources","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Next, we create a problem definition that includes these error sources:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Create a GRAPE problem with error sources\nrydberg_problem_with_errors = FidelityRobustGRAPEProblem(\n    UnitaryRobustGRAPEProblem(\n        t0=t0,\n        ntimes=ntimes,\n        ndim=5,\n        H0=H0,\n        nb_additional_param=1,\n        error_sources=[\n            ErrorSource(H_intensity_error),  # First error source: intensity fluctuations\n            ErrorSource(H_frequency_error)   # Second error source: frequency fluctuations\n        ]\n    ),\n    Diagonal([1, 2, 1, 0, 0]),  # Target state projection\n    cz                          # Target operation\n)","category":"page"},{"location":"examples/#Analyzing-Error-Sensitivity","page":"Examples","title":"Analyzing Error Sensitivity","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Now we can analyze how sensitive our previously optimized pulse is to these error sources:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Analyze sensitivity to errors with previously optimized pulse\nF, _, F_d2err, _ = calculate_fidelity_and_derivatives(rydberg_problem_with_errors, optim_pulse)\n\n# The F_d2err vector contains the second derivatives of fidelity with respect to error parameters\n# These values tell us how quickly the fidelity decreases with small errors\n\nprintln(\"Infidelity: $(1-F)\")\nprintln(\"Sensitivity to intensity errors: F = 1 - $(-F_d2err[1]/2) × ϵ²\")\nprintln(\"Sensitivity to frequency errors: F = 1 - $(-F_d2err[2]/2) × δ²\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For small errors, the infidelity (1-F) scales quadratically with the error amplitude. The coefficients -F_d2err[i]/2 indicate how sensitive the gate is to each error source - smaller values mean greater robustness.","category":"page"},{"location":"examples/#Designing-Robust-Pulses","page":"Examples","title":"Designing Robust Pulses","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"To optimize for robustness, we can include error sensitivity in the optimization objective:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Create parameters for robust optimization\nrobust_parameters = FidelityRobustGRAPEParameters(\n    x_initial = optim_pulse,  # Start from previously optimized pulse\n    regularization_functions = [regularization_cost_phase],\n    regularization_coeff1=[1e-7],\n    regularization_coeff2=[1e-7],\n    error_source_coeff=[0.5, 0.5],  # Non-zero weights for error sensitivities\n    time_limit=60,\n    additional_parameters = Dict(\n        :show_trace => true,\n        :show_every => 10,\n        :g_tol => 1e-9\n    )\n)\n\n# Run robust optimization\n# res_robust = optimize_fidelity_and_error_sources(rydberg_problem_with_errors, robust_parameters)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Setting non-zero error_source_coeff values instructs the optimizer to minimize both the gate infidelity and the sensitivity to errors, creating a control pulse that maintains high fidelity even in the presence of experimental imperfections.","category":"page"},{"location":"examples/#Frequency-Domain-Analysis","page":"Examples","title":"Frequency Domain Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"RobustGRAPE provides powerful tools for analyzing the frequency-dependent response of quantum gates to noise. This frequency domain analysis is crucial for understanding how a gate responds to noise at different timescales, which can inform both gate design and experimental implementation.","category":"page"},{"location":"examples/#Computing-the-Frequency-Response","page":"Examples","title":"Computing the Frequency Response","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The frequency response calculation transforms the time-dependent sensitivity of a quantum gate into the frequency domain:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Calculate frequency response with oversampling for better resolution\nresponse_fct, frequencies = calculate_fidelity_response_fft(\n    rydberg_problem_with_errors, \n    optim_pulse; \n    oversampling=30  # Higher values provide smoother frequency resolution\n)\n\n# Verify that DC component matches our direct calculation\n# The DC component (zero frequency) corresponds to static parameter shifts\n@assert isapprox(-F_d2err[1], 2*response_fct[1,1], rtol=1e-3, atol=1e-3)\n@assert isapprox(-F_d2err[2], 2*response_fct[1,2], rtol=1e-3, atol=1e-3)","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The calculate_fidelity_response_fft function computes how the gate fidelity responds to time-dependent noise at different frequencies. The returned matrices contain:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"response_fct: A matrix where each column corresponds to an error source, and each row to a frequency\nfrequencies: The corresponding frequency values (in units of Ω/2π)","category":"page"},{"location":"examples/#Visualizing-the-Intensity-Noise-Response","page":"Examples","title":"Visualizing the Intensity Noise Response","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Let's plot the response to intensity noise:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using PyPlot\nfig, ax = subplots()\nax.plot(frequencies, 0.25 * response_fct[:,1])\nax.set_xlim(0, 3)\nax.set_ylim(0, 1.5)\nax.set_xlabel(\"2πf/Ω\")\nax.set_ylabel(\"Laser intensity noise fidelity response\")\nax.set_title(\"Time-optimal gate response to intensity noise\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"This plot shows how sensitive the gate is to intensity fluctuations at different frequencies. Key insights:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Higher values indicate greater sensitivity to noise at that frequency\nThe DC component (f=0) corresponds to static offsets in laser intensity\nThe frequency axis is normalized to the Rabi frequency (Ω)\nPeaks in the response indicate frequencies where the gate is particularly vulnerable to noise","category":"page"},{"location":"examples/#Visualizing-the-Frequency-Noise-Response","page":"Examples","title":"Visualizing the Frequency Noise Response","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Similarly, we can plot the response to laser frequency noise:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"fig, ax = subplots()\nax.plot(frequencies, (2*π)^2 * response_fct[:,2])\nax.set_xlim(0, 3)\nax.set_ylim(0, 250)\nax.set_xlabel(\"2πf/Ω\")\nax.set_ylabel(\"Laser frequency noise fidelity response\")\nax.set_title(\"Time-optimal gate response to frequency noise\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The scaling factor (2*π)^2 adjusts the response to represent the sensitivity to frequency fluctuations in standard units, where the detuning is measured in radians/second.","category":"page"},{"location":"examples/#Applications-of-Frequency-Analysis","page":"Examples","title":"Applications of Frequency Analysis","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Frequency response analysis has several important applications:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Filter Design: Design filters to suppress noise at frequencies where the gate is most sensitive\nPulse Optimization: Modify control pulses to reduce sensitivity at problematic frequencies\nError Budgeting: Allocate error budget across different noise sources based on their impact\nHardware Requirements: Determine spectral noise requirements for experimental equipment","category":"page"},{"location":"examples/#Additional-Analysis:-Rydberg-Population","page":"Examples","title":"Additional Analysis: Rydberg Population","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Beyond fidelity and error sensitivity, RobustGRAPE allows you to analyze other important properties of quantum control pulses. For Rydberg atom systems, one crucial metric is the total time spent in the Rydberg state, as these states are susceptible to decoherence and decay.","category":"page"},{"location":"examples/#Measuring-Rydberg-State-Population","page":"Examples","title":"Measuring Rydberg State Population","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"We can calculate the integrated Rydberg state population during gate execution:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Create a specialized problem for measuring Rydberg population\nrydberg_problem_with_decay = deepcopy(rydberg_problem_with_errors)\n\n# Define an operator that detects population in Rydberg states\n# The [0,0,0,1,1] pattern targets the Rydberg states in our 5-level system\ndecay_operator(t, x, x_add, ϵ) = ϵ*collect(Diagonal([0, 0, 0, 1, 1]))\n\n# Update the problem to use this detection operator\nrydberg_problem_with_decay = (@set rydberg_problem_with_decay.unitary_problem.error_sources = [\n    ErrorSource(decay_operator)\n])\n\n# Calculate expectation values throughout the gate evolution\n# The result is a matrix of values for each time step and each error source\nrydberg_pops = calculate_expectation_values(rydberg_problem_with_decay, optim_pulse)\n\n# Extract the final integrated Rydberg population (first error source, end of evolution)\nrydberg_pop = rydberg_pops[end, 1]\nprintln(\"Integrated Rydberg population: $(rydberg_pop)/Ω\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"The integrated Rydberg population is a dimensionless quantity that, when multiplied by the decay rate, gives the total probability of decay during the gate operation. Lower values indicate a more resilient gate against decoherence.","category":"page"},{"location":"examples/#Visualizing-State-Evolution","page":"Examples","title":"Visualizing State Evolution","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"You can also visualize how different states evolve during the gate operation:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Calculate state evolution at multiple time points\ntime_points = LinRange(0, t0, 100)\nstate_evolution = calculate_state_evolution(rydberg_problem, optim_pulse, time_points)\n\n# Plot Rydberg state population vs time for an initial state\ninitial_state = [1, 0, 0, 0, 0]  # Example: starting in |00⟩ state\npopulations = [abs2(state_evolution[i,4,1]) + abs2(state_evolution[i,5,1]) for i in 1:length(time_points)]\n\n# Plot the result\nusing PyPlot\nfig, ax = subplots()\nax.plot(time_points, populations)\nax.set_xlabel(\"Time (1/Ω)\")\nax.set_ylabel(\"Rydberg state population\")\nax.set_title(\"Rydberg population during gate execution\")","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"By analyzing and optimizing these additional properties, you can design quantum gates that not only achieve high fidelity but are also robust against practical experimental constraints like decoherence and decay.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"For complete working examples, see the examples/ directory in the package repository.","category":"page"},{"location":"guide/getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"guide/getting-started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"guide/getting-started/","page":"Getting Started","title":"Getting Started","text":"To install RobustGRAPE.jl, use the Julia package manager:","category":"page"},{"location":"guide/getting-started/","page":"Getting Started","title":"Getting Started","text":"using Pkg\nPkg.add(\"RobustGRAPE\")  # From the Julia registry once published\n# OR\nPkg.add(url=\"https://github.com/USERNAME/RobustGRAPE.jl\")  # Directly from GitHub","category":"page"},{"location":"guide/getting-started/#Basic-Usage","page":"Getting Started","title":"Basic Usage","text":"","category":"section"},{"location":"guide/getting-started/","page":"Getting Started","title":"Getting Started","text":"Here's a simple example of using RobustGRAPE.jl to optimize a quantum gate:","category":"page"},{"location":"guide/getting-started/","page":"Getting Started","title":"Getting Started","text":"using RobustGRAPE\nusing LinearAlgebra\n\n# Define system parameters\nntimes = 100              # Number of time steps\ntotal_time = 1.0         # Total evolution time\nndim = 4                 # Dimension of Hilbert space\n\n# Define Hamiltonian function\nfunction H0(t, controls, additional_params)\n    # Example: A simple two-qubit system with controls\n    H = zeros(ComplexF64, ndim, ndim)\n    \n    # Add free evolution terms\n    # ...\n    \n    # Add control terms\n    # ...\n    \n    return H\nend\n\n# Define error sources\nerror_sources = [\n    ErrorSource(function(t, controls, add_params, eps)\n        # Example error Hamiltonian\n        return eps * randn() * I(ndim)\n    end)\n]\n\n# Create problem definition\nunitary_problem = UnitaryRobustGRAPEProblem(\n    t0 = total_time,\n    ntimes = ntimes,\n    ndim = ndim,\n    H0 = H0,\n    nb_additional_param = 0,\n    error_sources = error_sources\n)\n\n# Define target unitary and subspace\ntarget_unitary(x_add) = exp(-im * π/4 * (kron(σx, σx)))\nprojector = Matrix{Float64}(I, ndim, ndim)\n\nfidelity_problem = FidelityRobustGRAPEProblem(\n    unitary_problem = unitary_problem,\n    projector = projector,\n    target_unitary = target_unitary\n)\n\n# Create initial pulse amplitudes\nx_initial = zeros(ntimes)  # Initial control parameters\n\n# Define optimization parameters\nfidelity_parameters = FidelityRobustGRAPEParameters(\n    x_initial = x_initial,\n    regularization_functions = [regularization_cost_deriv2],  # Smooth pulses\n    regularization_coeff1 = [1e-5],  # Coefficient for first regularization\n    regularization_coeff2 = [1e-5],  # Coefficient for second regularization\n    error_source_coeff = [1e-3],     # Weight for error robustness\n    iterations = 500,                # Maximum iterations\n    solver_algorithm = LBFGS()       # Optimization algorithm\n)\n\n# Run optimization\nresult = optimize_fidelity_and_error_sources(fidelity_problem, fidelity_parameters)\n\n# Extract optimized parameters\noptimal_x = Optim.minimizer(result)\n\n# Evaluate final fidelity\nfinal_fidelity, _, _, _ = calculate_fidelity_and_derivatives(fidelity_problem, optimal_x)\nprintln(\"Final fidelity: \", final_fidelity)","category":"page"},{"location":"guide/getting-started/#Using-the-RydbergTools-Module","page":"Getting Started","title":"Using the RydbergTools Module","text":"","category":"section"},{"location":"guide/getting-started/","page":"Getting Started","title":"Getting Started","text":"RobustGRAPE.jl includes a specialized submodule for working with Rydberg atom systems, which provides pre-defined Hamiltonians and quantum gates commonly used in Rydberg atom quantum computing:","category":"page"},{"location":"guide/getting-started/","page":"Getting Started","title":"Getting Started","text":"using RobustGRAPE\nusing RobustGRAPE.RydbergTools\nusing LinearAlgebra\n\n# Access pre-defined Rydberg Hamiltonians\nH = rydberg_hamiltonian_symmetric_blockaded(π/2, 0, 0)\n\n# Create a CZ gate with a phase parameter\nθ = π/4\ncz_gate = cz_with_1q_phase_symmetric(θ)\n\n# Define a Hamiltonian function for GRAPE optimization\nfunction H0(t, ϕ, x_add)\n    # ϕ contains the control parameters (laser phase)\n    # x_add contains additional parameters\n    return rydberg_hamiltonian_symmetric_blockaded(ϕ[1], 0, 0)\nend\n\n# Now use this Hamiltonian in your GRAPE optimization\n# ...","category":"page"},{"location":"guide/getting-started/","page":"Getting Started","title":"Getting Started","text":"The RydbergTools module includes functions for:","category":"page"},{"location":"guide/getting-started/","page":"Getting Started","title":"Getting Started","text":"Hamiltonians in different Rydberg atom configurations (symmetric, blockaded, full)\nStandard quantum gates like the CZ gate with phase parameters\nUtility functions for phase handling (like unwrap_phase)","category":"page"},{"location":"guide/getting-started/","page":"Getting Started","title":"Getting Started","text":"See the Rydberg Tools API for complete documentation of these functions.","category":"page"},{"location":"guide/getting-started/#Workflow","page":"Getting Started","title":"Workflow","text":"","category":"section"},{"location":"guide/getting-started/","page":"Getting Started","title":"Getting Started","text":"The typical workflow with RobustGRAPE.jl involves:","category":"page"},{"location":"guide/getting-started/","page":"Getting Started","title":"Getting Started","text":"Define the quantum system\nSpecify Hamiltonian and dimension\nDefine error sources\nFor Rydberg systems, use the RydbergTools module\nSet up the optimization problem\nCreate problem definition\nSpecify target unitary operation\nConfigure regularization and robustness weights\nRun optimization\nUse optimize_fidelity_and_error_sources function\nAdjust regularization parameters if needed\nAnalyze results\nCalculate final fidelity\nAnalyze error robustness using calculate_fidelity_response\nFor frequency domain analysis, use calculate_fidelity_response_fft\nVisualize optimized control pulses","category":"page"},{"location":"guide/getting-started/#Example:-Rydberg-CZ-Gate","page":"Getting Started","title":"Example: Rydberg CZ Gate","text":"","category":"section"},{"location":"guide/getting-started/","page":"Getting Started","title":"Getting Started","text":"Here's a simplified example of optimizing a CZ gate in a Rydberg atom system:","category":"page"},{"location":"guide/getting-started/","page":"Getting Started","title":"Getting Started","text":"using RobustGRAPE\nusing RobustGRAPE.RydbergTools\nusing LinearAlgebra\nusing Optim\nusing Random\n\n# Define system parameters\nntimes = 200\ntotal_time = 5.0\n\n# Define Hamiltonian using RydbergTools\nH0(t, ϕ, x_add) = rydberg_hamiltonian_symmetric_blockaded(ϕ[1], 0, 0)\ncz(x_add) = cz_with_1q_phase_symmetric(x_add[1])\n\n# Create optimization problem\nproblem = FidelityRobustGRAPEProblem(\n    UnitaryRobustGRAPEProblem(\n        t0 = total_time,\n        ntimes = ntimes,\n        ndim = 5,  # Dimension of the Rydberg system\n        H0 = H0,\n        nb_additional_param = 1,\n        error_sources = []\n    ),\n    Diagonal([1, 2, 1, 0, 0]),  # Target state projection\n    cz  # Target CZ operation\n)\n\n# Run optimization (simplified)\n# ... \n\n# For complete examples, see the Examples section","category":"page"},{"location":"guide/getting-started/#Next-Steps","page":"Getting Started","title":"Next Steps","text":"","category":"section"},{"location":"guide/getting-started/","page":"Getting Started","title":"Getting Started","text":"Explore the API documentation for more details on each component of RobustGRAPE.jl:","category":"page"},{"location":"guide/getting-started/","page":"Getting Started","title":"Getting Started","text":"Types: Core data structures\nUnitary Calculations: Computing evolution operators\nFidelity Calculations: Fidelity metrics and optimization\nRegularization: Pulse smoothing techniques\nRydberg Tools: Rydberg atom specific functionality","category":"page"},{"location":"guide/getting-started/","page":"Getting Started","title":"Getting Started","text":"For complete working examples, check out the Examples page.","category":"page"},{"location":"guide/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"guide/introduction/#What-is-GRAPE?","page":"Introduction","title":"What is GRAPE?","text":"","category":"section"},{"location":"guide/introduction/","page":"Introduction","title":"Introduction","text":"GRadient Ascent Pulse Engineering (GRAPE) is a numerical optimal control algorithm for designing control pulses in quantum systems. It was first introduced by Khaneja et al. in 2005 and has since become one of the standard tools in quantum control.","category":"page"},{"location":"guide/introduction/","page":"Introduction","title":"Introduction","text":"The algorithm works by:  ","category":"page"},{"location":"guide/introduction/","page":"Introduction","title":"Introduction","text":"Parameterizing control pulses (typically as piecewise constant functions)\nComputing the gradient of a fidelity function with respect to pulse parameters\nUsing gradient-based optimization to maximize fidelity","category":"page"},{"location":"guide/introduction/#What-is-Robust-GRAPE?","page":"Introduction","title":"What is Robust GRAPE?","text":"","category":"section"},{"location":"guide/introduction/","page":"Introduction","title":"Introduction","text":"Robust GRAPE extends the standard GRAPE algorithm to include robustness against various sources of error and noise. This is achieved by optimizing not only the fidelity of the quantum operation but also its sensitivity to perturbations.","category":"page"},{"location":"guide/introduction/","page":"Introduction","title":"Introduction","text":"The key features of Robust GRAPE include:","category":"page"},{"location":"guide/introduction/","page":"Introduction","title":"Introduction","text":"Error robustness: Optimization against specific error models\nFrequency domain analysis: Understanding sensitivity to noise at different frequencies\nRegularization: Ensuring smooth and experimentally feasible control pulses","category":"page"},{"location":"guide/introduction/#Applications","page":"Introduction","title":"Applications","text":"","category":"section"},{"location":"guide/introduction/","page":"Introduction","title":"Introduction","text":"RobustGRAPE.jl is particularly suited for optimizing quantum gates in systems such as:","category":"page"},{"location":"guide/introduction/","page":"Introduction","title":"Introduction","text":"Rydberg atom arrays\nTrapped ions\nSuperconducting qubits\nNMR systems","category":"page"},{"location":"guide/introduction/","page":"Introduction","title":"Introduction","text":"These systems often require precise control in the presence of noise and experimental limitations.","category":"page"},{"location":"guide/#User-Guide","page":"User Guide","title":"User Guide","text":"","category":"section"},{"location":"guide/","page":"User Guide","title":"User Guide","text":"This guide provides an introduction to RobustGRAPE.jl and instructions for using it to optimize robust quantum control pulses.","category":"page"},{"location":"guide/#Contents","page":"User Guide","title":"Contents","text":"","category":"section"},{"location":"guide/","page":"User Guide","title":"User Guide","text":"Introduction: Learn about GRAPE and robust quantum control\nGetting Started: A quick tutorial to get you up and running","category":"page"},{"location":"guide/","page":"User Guide","title":"User Guide","text":"To dive into the API details, see the API Reference section.","category":"page"},{"location":"#RobustGRAPE.jl","page":"Home","title":"RobustGRAPE.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia package for robust quantum optimal control using the GRAPE algorithm","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RobustGRAPE.jl is a package for optimizing quantum control pulses using the GRadient Ascent Pulse Engineering (GRAPE) algorithm, with additional features for robustness against noise and errors. The package is designed for optimizing control pulses for quantum gates in systems like Rydberg atoms, trapped ions, and superconducting qubits.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Optimization of quantum control pulses for high-fidelity gates\nRobustness against various error sources and noise\nFrequency domain analysis of robustness\nSupport for arbitrary Hamiltonians and quantum systems\nEfficient gradient calculations for optimization\nVarious regularization techniques for pulse smoothing\nSpecialized tools for Rydberg atom systems through the RydbergTools module","category":"page"},{"location":"#RydbergTools-Module","page":"Home","title":"RydbergTools Module","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package includes a specialized module for working with Rydberg atom systems:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using RobustGRAPE.RydbergTools\n\n# Access pre-defined Rydberg Hamiltonians\nH = rydberg_hamiltonian_symmetric_blockaded(π/2, 0, 0)\n\n# Create a CZ gate with a phase parameter\ncz_gate = cz_with_1q_phase_symmetric(π/4)","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more details, see the Rydberg Tools API.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install the package, use the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"RobustGRAPE\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or to install the development version from the repository:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/USERNAME/RobustGRAPE.jl\")","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"See the Getting Started guide for a quick introduction to using RobustGRAPE.jl.","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Check out the Examples page for complete working examples, including:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Time-optimal CZ gate implementation using Rydberg atoms\nRobust pulse design against intensity and frequency errors\nFrequency domain analysis of optimized pulses","category":"page"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package's documentation and code organization was developed with the assistance of Claude, an AI assistant by Anthropic.","category":"page"},{"location":"api/rydberg/#Rydberg-Tools","page":"Rydberg Tools","title":"Rydberg Tools","text":"","category":"section"},{"location":"api/rydberg/#Rydberg-Specific-Functions","page":"Rydberg Tools","title":"Rydberg-Specific Functions","text":"","category":"section"},{"location":"api/rydberg/","page":"Rydberg Tools","title":"Rydberg Tools","text":"This page documents functions specific to Rydberg atom systems in RobustGRAPE.jl.","category":"page"},{"location":"api/rydberg/#Hamiltonian-Functions","page":"Rydberg Tools","title":"Hamiltonian Functions","text":"","category":"section"},{"location":"api/rydberg/#RobustGRAPE.RydbergTools.rydberg_hamiltonian_symmetric_blockaded","page":"Rydberg Tools","title":"RobustGRAPE.RydbergTools.rydberg_hamiltonian_symmetric_blockaded","text":"rydberg_hamiltonian_symmetric_blockaded(ϕ::Real, ϵ::Real, δ::Real)\n\nConstructs the Hamiltonian for a symmetric Rydberg-blockaded two-atom system.\n\nBasis\n\n|00⟩, |01⟩, |11⟩, |0r⟩, |W⟩ where |W⟩ = (|1r⟩ + |r1⟩)/√2\n\nParameters\n\nϕ::Real: Phase of the driving field\nϵ::Real: Relative amplitude deviation parameter\nδ::Real: Detuning of the Rydberg state\n\nMathematical form\n\nH = \nbeginpmatrix\n0  0  0  0  0 \n0  0  0  frac(1+epsilon)e^-iphi2  0 \n0  0  0  0  frac(1+epsilon)e^-iphisqrt2 \n0  frac(1+epsilon)e^iphi2  0  delta  0 \n0  0  frac(1+epsilon)e^iphisqrt2  0  delta\nendpmatrix\n\nReturns\n\nMatrix representing the Hamiltonian in the symmetric basis described above\n\n\n\n\n\n","category":"function"},{"location":"api/rydberg/#RobustGRAPE.RydbergTools.rydberg_hamiltonian_full_blockaded","page":"Rydberg Tools","title":"RobustGRAPE.RydbergTools.rydberg_hamiltonian_full_blockaded","text":"rydberg_hamiltonian_full_blockaded(ϕ::Real, ϵ::Real, δ::Real)\n\nConstructs the Hamiltonian for a fully-described Rydberg-blockaded two-atom system.\n\nBasis\n\n|00⟩, |01⟩, |10⟩, |11⟩, |0r⟩, |r0⟩, |W'⟩ where |W'⟩ = (|1r⟩ + |r1⟩)/√2\n\nParameters\n\nϕ::Real: Phase of the driving field\nϵ::Real: Relative amplitude deviation parameter\nδ::Real: Detuning of the Rydberg state\n\nMathematical form\n\nH = \nbeginpmatrix\n0  0  0  0  0  0  0 \n0  0  0  0  frac(1+epsilon)e^-iphi2  0  0 \n0  0  0  0  0  frac(1+epsilon)e^-iphi2  0 \n0  0  0  0  0  0  frac(1+epsilon)e^-iphisqrt2 \n0  frac(1+epsilon)e^iphi2  0  0  delta  0  0 \n0  0  frac(1+epsilon)e^iphi2  0  0  delta  0 \n0  0  0  frac(1+epsilon)e^iphisqrt2  0  0  delta\nendpmatrix\n\nReturns\n\nMatrix representing the Hamiltonian in the basis described above\n\n\n\n\n\n","category":"function"},{"location":"api/rydberg/#RobustGRAPE.RydbergTools.rydberg_hamiltonian_full","page":"Rydberg Tools","title":"RobustGRAPE.RydbergTools.rydberg_hamiltonian_full","text":"rydberg_hamiltonian_full(ϕ::Real, Ω1::Real, Ω2::Real, δ1::Real, δ2::Real, B::Real)\n\nConstructs the full Hamiltonian for a two-atom Rydberg system without symmetry constraints.\n\nBasis\n\n|00⟩, |01⟩, |10⟩, |11⟩, |0r⟩, |r0⟩, |1r⟩, |r1⟩, |rr⟩\n\nParameters\n\nϕ::Real: Phase of the driving field\nΩ1::Real: Rabi frequency for the first atom\nΩ2::Real: Rabi frequency for the second atom\nδ1::Real: Detuning for the first atom\nδ2::Real: Detuning for the second atom\nB::Real: Rydberg-Rydberg blockade shift\n\nMathematical form\n\nH = \nbeginpmatrix\n0  0  0  0  0  0  0  0  0 \n0  0  0  0  fracOmega_1 e^-iphi2  0  0  0  0 \n0  0  0  0  0  fracOmega_2 e^-iphi2  0  0  0 \n0  0  0  0  0  0  fracOmega_1 e^-iphi2  Omega_2 e^-iphi  0 \n0  fracOmega_1 e^iphi2  0  0  delta_1  0  0  0  0 \n0  0  fracOmega_2 e^iphi2  0  0  delta_2  0  0  0 \n0  0  0  0  fracOmega_1 e^iphi2  0  delta_1  0  fracOmega_2 e^-iphi2 \n0  0  0  0  0  fracOmega_2 e^iphi2  0  delta_2  fracOmega_1 e^-iphi2 \n0  0  0  0  0  0  fracOmega_2 e^iphi2  fracOmega_1 e^iphi2  delta_1 + delta_2 + B\nendpmatrix\n\nReturns\n\nMatrix representing the Hamiltonian in the full basis described above\n\n\n\n\n\n","category":"function"},{"location":"api/rydberg/#Gate-Functions","page":"Rydberg Tools","title":"Gate Functions","text":"","category":"section"},{"location":"api/rydberg/#RobustGRAPE.RydbergTools.cz_with_1q_phase_symmetric","page":"Rydberg Tools","title":"RobustGRAPE.RydbergTools.cz_with_1q_phase_symmetric","text":"cz_with_1q_phase_symmetric(θ::Real)\n\nConstructs the CZ gate with additional single-qubit phase in the symmetric subspace.\n\nBasis\n\n|00⟩, |01⟩, |11⟩, |0r⟩, |W⟩ (same as in rydberg_hamiltonian_symmetric_blockaded)\n\nParameters\n\nθ::Real: Single-qubit phase parameter\n\nMathematical form\n\nU = \nbeginpmatrix\n1  0  0  0  0 \n0  e^itheta  0  0  0 \n0  0  e^i(2theta+pi)  0  0 \n0  0  0  0  0 \n0  0  0  0  0\nendpmatrix\n\nThe diagonal structure encodes a CZ gate with additional single-qubit phase rotations.\n\nReturns\n\nDiagonal matrix representing the CZ gate with phase rotations\n\n\n\n\n\n","category":"function"},{"location":"api/rydberg/#RobustGRAPE.RydbergTools.cz_with_1q_phase_full","page":"Rydberg Tools","title":"RobustGRAPE.RydbergTools.cz_with_1q_phase_full","text":"cz_with_1q_phase_full(θ::Real; rydberg_dimension::Int = 5)\n\nConstructs the CZ gate with additional single-qubit phase in the full computational basis.\n\nBasis\n\n|00⟩, |01⟩, |10⟩, |11⟩, |0r⟩, |r0⟩, |1r⟩, |r1⟩, |rr⟩ (same as in rydberg_hamiltonian_full)\n\nParameters\n\nθ::Real: Single-qubit phase parameter\nrydberg_dimension::Int=5: Dimension of the Rydberg subspace (optional, default: 5)\n\nMathematical form\n\nU = \nbeginpmatrix\n1  0  0  0  0  0  0  0  0 \n0  e^itheta  0  0  0  0  0  0  0 \n0  0  e^itheta  0  0  0  0  0  0 \n0  0  0  e^i(2theta+pi)  0  0  0  0  0 \n0  0  0  0  0  0  0  0  0 \n0  0  0  0  0  0  0  0  0 \n0  0  0  0  0  0  0  0  0 \n0  0  0  0  0  0  0  0  0 \n0  0  0  0  0  0  0  0  0\nendpmatrix\n\nThe diagonal structure encodes a CZ gate with additional single-qubit phase rotations.\n\nReturns\n\nDiagonal matrix representing the CZ gate with phase rotations in the full basis\n\n\n\n\n\n","category":"function"},{"location":"api/rydberg/#Utility-Functions","page":"Rydberg Tools","title":"Utility Functions","text":"","category":"section"},{"location":"api/rydberg/#RobustGRAPE.RydbergTools.unwrap_phase","page":"Rydberg Tools","title":"RobustGRAPE.RydbergTools.unwrap_phase","text":"unwrap_phase(ϕ)\n\nUnwraps a sequence of phase values by removing jumps greater than π.\n\nAdjusts phase values to maintain continuity across the 2π boundary, eliminating artificial discontinuities in phase data while preserving the actual phase evolution. Particularly useful for plotting phase values to avoid discontinuous jumps.\n\nParameters\n\nϕ: Array of phase values to unwrap\n\nReturns\n\nAn array of unwrapped phase values with the same length as the input\n\n\n\n\n\n","category":"function"},{"location":"api/regularization/#Regularization","page":"Regularization","title":"Regularization","text":"","category":"section"},{"location":"api/regularization/#Regularization-Functions","page":"Regularization","title":"Regularization Functions","text":"","category":"section"},{"location":"api/regularization/","page":"Regularization","title":"Regularization","text":"This page documents the regularization functions available in RobustGRAPE.jl, which are used to enforce desirable properties on the optimized control pulses such as smoothness and bounded amplitudes.","category":"page"},{"location":"api/regularization/#RobustGRAPE.regularization_cost","page":"Regularization","title":"RobustGRAPE.regularization_cost","text":"regularization_cost(x::Vector{<:Real})\n\nCompute regularization costs and their gradients to promote smoothness in control pulses.\n\nThis function calculates two regularization terms:\n\nFirst-order regularization (reg1): Penalizes large changes between consecutive elements (first derivative)\nSecond-order regularization (reg2): Penalizes large changes in the rate of change (second derivative)\n\nArguments\n\nx::Vector{<:Real}: The control parameter vector to regularize\n\nReturns\n\nA tuple with four elements:\n\nreg1::Real: First-order regularization cost (sum of squared differences)\njac1::Vector{<:Real}: Gradient of the first-order regularization with respect to x\nreg2::Real: Second-order regularization cost (sum of squared second differences)\njac2::Vector{<:Real}: Gradient of the second-order regularization with respect to x\n\nExamples\n\nx = [0.0, 0.1, 0.3, 0.2, 0.1]\nreg1, jac1, reg2, jac2 = regularization_cost(x)\n\n\n\n\n\nregularization_cost(x::Vector{<:Real}, f::Function, df::Function)\n\nCompute regularization costs and their gradients for transformed control parameters.\n\nThis function applies a transformation function f to the control parameters before calculating regularization, and then applies the chain rule using df to compute the gradient with respect to the original parameters.\n\nArguments\n\nx::Vector{<:Real}: The original control parameter vector\nf::Function: Transformation function to apply to each element of x\ndf::Function: Derivative of the transformation function\n\nReturns\n\nA tuple with four elements:\n\nreg1::Real: First-order regularization cost on the transformed parameters\njac1::Vector{<:Real}: Gradient of the first-order regularization with respect to original parameters\nreg2::Real: Second-order regularization cost on the transformed parameters\njac2::Vector{<:Real}: Gradient of the second-order regularization with respect to original parameters\n\nExamples\n\nx = [0.0, 0.1, 0.3, 0.2, 0.1]\nf(x) = sin(x)\ndf(x) = cos(x)\nreg1, jac1, reg2, jac2 = regularization_cost(x, f, df)\n\n\n\n\n\n","category":"function"},{"location":"api/regularization/#RobustGRAPE.regularization_cost_phase","page":"Regularization","title":"RobustGRAPE.regularization_cost_phase","text":"regularization_cost_phase(ϕs::Vector{<:Real})\n\nCompute regularization costs and their gradients for phase-based control parameters.\n\nThis function calculates regularization terms for both sine and cosine of the phase values, which promotes smoothness in the complex phasor representation of the phase controls. This is particularly useful when optimizing phase-based control sequences where the physical meaning depends on the periodic nature of phases.\n\nArguments\n\nϕs::Vector{<:Real}: The vector of phase values (in radians) to regularize\n\nReturns\n\nA tuple with four elements:\n\nreg1::Real: First-order regularization cost (sum of cos and sin components)\njac1::Vector{<:Real}: Gradient of the first-order regularization with respect to ϕs\nreg2::Real: Second-order regularization cost (sum of cos and sin components)\njac2::Vector{<:Real}: Gradient of the second-order regularization with respect to ϕs\n\nExamples\n\nϕs = [0.0, 0.1, 0.3, 0.2, 0.1]\nreg1, jac1, reg2, jac2 = regularization_cost_phase(ϕs)\n\n\n\n\n\n","category":"function"},{"location":"api/regularization/","page":"Regularization","title":"Regularization","text":"Note: Add other regularization functions from Regularization.jl as they are implemented.","category":"page"}]
}
